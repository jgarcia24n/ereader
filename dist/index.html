<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A powerful EPUB reader with media overlay support, Google Drive sync, and offline capabilities">
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="EPUB Reader">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./icon-192.png">
    <title>EPUB3 Media Overlay Reader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --secondary: #64748b;
            --accent: #f59e0b;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-reader: #ffffff;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --border: #334155;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            overflow: hidden;
            line-height: 1.6;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
        }

        /* Library View Styles */
        .library-view {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            display: none;
        }

        .library-view.active {
            display: block;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .library-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .library-stats {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .book-card {
            background: var(--bg-card);
            border-radius: 0.75rem;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
        }

        .book-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
            border-color: var(--primary);
        }

        .book-card-cover {
            width: 100%;
            height: 280px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            position: relative;
            overflow: hidden;
        }

        .book-card-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .book-card-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .book-card-progress-bar {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
        }

        .book-card-info {
            padding: 1rem;
        }

        .book-card-title {
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .book-card-author {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .book-card-path {
            font-size: 0.75rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            opacity: 0.8;
        }

        .book-card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border);
        }

        .book-card-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .book-card:hover .book-card-actions {
            opacity: 1;
        }

        .book-card-action-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 2rem;
            height: 2rem;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .book-card-action-btn:hover {
            background: rgba(220, 38, 38, 0.9);
            transform: scale(1.1);
        }

        #libraryMenuBtn:hover {
            background: var(--bg-main);
            border-color: var(--primary);
        }

        #libraryMenu button:hover {
            background: var(--bg-main) !important;
            color: var(--primary) !important;
        }

        .empty-library {
            text-align: center;
            padding: 4rem 2rem;
        }

        .empty-library-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .empty-library-text {
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }

        /* Reader View Styles */
        .reader-view {
            flex: 1;
            display: none;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .reader-view.active {
            display: flex;
        }

        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            position: relative;
            z-index: 100;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .file-upload-wrapper {
            position: relative;
            overflow: hidden;
        }

        .file-upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9375rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
            display: flex;
            align-items: center;
            gap: 0.625rem;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .file-upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .file-upload-btn:active {
            transform: translateY(0);
        }

        input[type="file"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }

        .icon-btn {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.625rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 2.5rem;
            height: 2.5rem;
            backdrop-filter: blur(10px);
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .status-bar {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            padding: 0.75rem 1rem;
            background: var(--bg-main);
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }

        .book-info {
            display: flex;
            gap: 1rem;
            align-items: center;
            width: 100%;
        }

        .book-cover {
            flex-shrink: 0;
            width: 60px;
            height: 60px;
            border-radius: 0.375rem;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .book-details {
            flex: 1;
            min-width: 0;
        }

        .book-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.25rem;
        }

        .book-author {
            font-size: 0.875rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.25rem;
        }

        .book-chapter {
            font-size: 0.8125rem;
            color: var(--accent);
            font-weight: 600;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        .reader-area {
            flex: 1;
            background: var(--bg-reader);
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            transition: all 0.3s ease;
        }

        .reader-area.paginated {
            overflow: hidden;
        }

        .reader-area.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
        }

        .reader-controls {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 1100;
            pointer-events: auto;
        }

        .page-navigation {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            display: none;
            gap: 0.5rem;
            z-index: 1100;
            pointer-events: auto;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
        }

        .page-navigation.active {
            display: flex;
        }

        .page-nav-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            color: #475569;
            padding: 0.625rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.75rem;
            height: 2.75rem;
            font-size: 1.25rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .page-nav-btn:hover:not(:disabled) {
            background: white;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .page-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .page-info {
            color: white;
            font-size: 0.875rem;
            font-weight: 600;
            padding: 0 0.5rem;
            min-width: 80px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .reader-controls {
                bottom: 1rem;
            }
        }

        .reader-area.dark-mode {
            background: #1a1a1a;
        }

        .reader-area.dark-mode #viewer {
            color: #e0e0e0;
        }

        .reader-area.dark-mode #viewer h1,
        .reader-area.dark-mode #viewer h2,
        .reader-area.dark-mode #viewer h3 {
            color: #f0f0f0;
        }

        .reader-area.dark-mode .epub-media-overlay-active {
            background-color: #ffa500 !important;
            color: #000 !important;
        }

        .reader-area.fullscreen .reader-controls {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 0.5rem;
            border-radius: 0.5rem;
        }

        .reader-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            color: #475569;
            padding: 0.625rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.75rem;
            height: 2.75rem;
            font-size: 1.25rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
        }

        .reader-btn:hover {
            background: white;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .reader-btn:active {
            transform: translateY(0) scale(1);
        }

        .reader-btn.active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .reader-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .reader-area.fullscreen .reader-btn {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        #viewer {
            max-width: 800px;
            margin: 0 auto;
            padding: 3rem 2rem;
            font-size: 1.125rem;
            line-height: 1.8;
            color: #1e293b;
            font-family: var(--reader-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif);
        }

        #viewer.font-serif {
            font-family: Georgia, 'Times New Roman', serif;
        }

        #viewer.font-sans {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        #viewer.font-mono {
            font-family: 'Courier New', Courier, monospace;
        }

        #viewer.font-dyslexic {
            font-family: 'Comic Sans MS', 'Comic Sans', cursive;
        }

        #viewer.font-palatino {
            font-family: Palatino, 'Palatino Linotype', 'Book Antiqua', serif;
        }

        #viewer.font-garamond {
            font-family: Garamond, 'Garamond Premier Pro', 'EB Garamond', serif;
        }

        #viewer.font-bookerly {
            font-family: 'Iowan Old Style', 'Palatino Linotype', 'URW Palladio L', P052, serif;
        }

        #viewer.font-opensans {
            font-family: 'Open Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #viewer.font-roboto {
            font-family: Roboto, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #viewer.font-arial {
            font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
        }

        #viewer.font-verdana {
            font-family: Verdana, Geneva, sans-serif;
        }

        #viewer.font-atkinson {
            font-family: 'Atkinson Hyperlegible', 'Comic Sans MS', sans-serif;
        }

        #viewer.spacing-compact {
            line-height: 1.4;
        }

        #viewer.spacing-normal {
            line-height: 1.8;
        }

        #viewer.spacing-relaxed {
            line-height: 2.2;
        }

        #viewer.spacing-loose {
            line-height: 2.6;
        }

        #viewer.align-left p {
            text-align: left;
        }

        #viewer.align-justify p {
            text-align: justify;
            text-justify: inter-word;
        }

        #viewer.align-left {
            text-align: left;
        }

        #viewer.align-justify {
            text-align: justify;
            text-justify: inter-word;
        }

        #viewer img {
            max-width: 100% !important;
            height: auto !important;
            display: block;
            margin: 1rem auto;
        }

        #viewer h1, #viewer h2, #viewer h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #0f172a;
            font-weight: 700;
        }

        #viewer h1 {
            font-size: 2rem;
        }

        #viewer h2 {
            font-size: 1.5rem;
        }

        #viewer h3 {
            font-size: 1.25rem;
        }

        #viewer p {
            margin-bottom: 1.25rem;
        }

        .epub-media-overlay-active {
            background-color: #fef3c7 !important;
            color: #92400e !important;
            border-radius: 0.25rem;
            transition: all 0.3s ease;
        }

        .controls-panel {
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .controls-main {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            background: #334155;
            color: var(--text-primary);
            border: none;
            padding: 0.75rem;
            border-radius: 9999px;
            cursor: pointer;
            font-size: 0.9375rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.625rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            width: 3rem;
            height: 3rem;
        }

        .btn:hover:not(:disabled) {
            background: #475569;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #1e293b;
            color: #475569;
            cursor: not-allowed;
            transform: none;
        }

        .btn-icon-circular {
            padding: 0.5rem;
            width: 3rem;
            height: 3rem;
        }

        .btn-icon-circular svg {
            width: 100%;
            height: 100%;
        }

        .btn-play {
            background: #f59e0b;
            color: white;
            padding: 1rem;
            font-size: 1.0625rem;
            border: none;
            width: 4rem;
            height: 4rem;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }

        .btn-play:hover:not(:disabled) {
            background: #d97706;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.6);
        }

        .btn-play:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn-text {
            display: none;
        }

        .btn-icon {
            font-size: 1.25rem;
        }

        .btn-play .btn-icon {
            font-size: 1.5rem;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0;
            background: transparent;
            border-radius: 0;
            font-size: 0.875rem;
            border: none;
            box-shadow: none;
            justify-content: center;
            flex-wrap: wrap;
        }

        .speed-btn {
            background: #334155;
            color: #cbd5e1;
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s ease;
            min-width: 3rem;
        }

        .speed-btn:hover {
            background: #475569;
        }

        .speed-btn.active {
            background: #f59e0b;
            color: white;
        }

        .speed-icon {
            display: none;
        }

        #speedSlider {
            display: none;
        }

        #speedDisplay {
            display: none;
        }

        .debug-panel {
            background: var(--bg-main);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }

        .debug-panel h3 {
            margin-bottom: 0.5rem;
            color: var(--accent);
            font-size: 0.875rem;
        }

        .debug-item {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .debug-item:last-child {
            border-bottom: none;
        }

        .notification {
            position: fixed;
            top: 5rem;
            right: 1rem;
            background: white;
            color: #0f172a;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            animation: slideIn 0.3s ease;
            max-width: 400px;
            border-left: 4px solid var(--primary);
        }

        @keyframes slideIn {
            from {
                transform: translateX(calc(100% + 2rem));
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.error {
            border-left-color: #dc2626;
            background: #fef2f2;
            color: #7f1d1d;
        }

        .notification.success {
            border-left-color: #16a34a;
            background: #f0fdf4;
            color: #14532d;
        }

        .notification.info {
            border-left-color: var(--primary);
            background: #eff6ff;
            color: #1e3a8a;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .library-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 1rem;
            }

            .book-card-cover {
                height: 220px;
            }

            h1 {
                font-size: 1.125rem;
            }

            .header {
                padding: 0.875rem 1rem;
            }

            .header-top {
                margin-bottom: 0.75rem;
            }

            .file-upload-btn {
                padding: 0.5rem 1rem;
                font-size: 0.8125rem;
            }

            #viewer {
                padding: 2rem 1rem;
                font-size: 1rem;
            }

            .controls-panel {
                padding: 1rem;
            }

            .controls-main {
                gap: 0.5rem;
            }

            .speed-control {
                font-size: 0.8125rem;
                padding: 0.5rem 0.75rem;
            }

            .status-bar {
                font-size: 0.8125rem;
                gap: 0.75rem;
            }

            .notification {
                right: 1rem;
                left: 1rem;
                max-width: none;
            }
        }

        .reader-area.dark-mode::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        .reader-area.dark-mode::-webkit-scrollbar-thumb {
            background: #555;
        }

        .reader-area.dark-mode::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Scrollbar Styling */
        .reader-area::-webkit-scrollbar,
        .library-view::-webkit-scrollbar {
            width: 8px;
        }

        .reader-area::-webkit-scrollbar-track,
        .library-view::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .reader-area::-webkit-scrollbar-thumb,
        .library-view::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .reader-area::-webkit-scrollbar-thumb:hover,
        .library-view::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .library-view::-webkit-scrollbar-track {
            background: var(--bg-main);
        }

        .library-view::-webkit-scrollbar-thumb {
            background: var(--border);
        }

        .debug-panel::-webkit-scrollbar {
            width: 6px;
        }

        .debug-panel::-webkit-scrollbar-track {
            background: var(--bg-card);
        }

        .debug-panel::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        /* Cloud Import Modal */
        .cloud-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .cloud-modal-content {
            background: var(--bg-card);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .cloud-modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cloud-modal-description {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }

        .cloud-modal-input {
            width: 100%;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg-main);
            color: var(--text-primary);
            font-size: 0.9375rem;
            margin-bottom: 1rem;
            font-family: inherit;
        }

        .cloud-modal-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .cloud-modal-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .cloud-modal-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            font-size: 0.9375rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cloud-modal-btn-primary {
            background: linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%);
            color: white;
        }

        .cloud-modal-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.4);
        }

        .cloud-modal-btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .cloud-modal-btn-secondary {
            background: var(--bg-main);
            color: var(--text-primary);
        }

        .cloud-modal-btn-secondary:hover {
            background: var(--border);
        }

        .cloud-help {
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .cloud-help-title {
            font-weight: 600;
            color: #06b6d4;
            margin-bottom: 0.25rem;
        }

        .cloud-icon-badge {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            background: linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(6, 182, 212, 0.4);
            z-index: 10;
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .settings-content {
            background: var(--bg-card);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 400px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .settings-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .settings-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
            transition: color 0.2s;
        }

        .settings-close:hover {
            color: var(--text-primary);
        }

        .settings-section {
            margin-bottom: 1.5rem;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .settings-slider {
            width: 100%;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            cursor: pointer;
            border-radius: 50%;
        }

        .settings-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .settings-value {
            display: inline-block;
            margin-left: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .settings-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--bg-main);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 0.5rem;
        }

        .settings-toggle:hover {
            background: var(--border);
        }

        .settings-toggle-label {
            font-size: 0.9375rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 26px;
            background: var(--border);
            border-radius: 13px;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--primary);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(22px);
        }

        .sleep-timer-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .sleep-timer-btn {
            flex: 1;
            background: var(--bg-main);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.8125rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .sleep-timer-btn:hover {
            background: var(--border);
        }

        .sleep-timer-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .sleep-timer-status {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(37, 99, 235, 0.1);
            border: 1px solid rgba(37, 99, 235, 0.3);
            border-radius: 0.375rem;
            font-size: 0.8125rem;
            color: var(--text-primary);
            text-align: center;
        }

        .sleep-timer-status.active {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .font-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .font-option {
            background: var(--bg-main);
            color: var(--text-primary);
            border: 2px solid var(--border);
            padding: 0.75rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.8125rem;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
        }

        .font-option:hover {
            background: var(--border);
        }

        .font-option.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .font-option.serif {
            font-family: Georgia, 'Times New Roman', serif;
        }

        .font-option.sans {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .font-option.mono {
            font-family: 'Courier New', Courier, monospace;
        }

        .font-option.dyslexic {
            font-family: 'Comic Sans MS', 'Comic Sans', cursive;
        }

        .font-option.palatino {
            font-family: Palatino, 'Palatino Linotype', 'Book Antiqua', serif;
        }

        .font-option.garamond {
            font-family: Garamond, 'Garamond Premier Pro', serif;
        }

        .font-option.bookerly {
            font-family: 'Iowan Old Style', 'Palatino Linotype', serif;
        }

        .font-option.opensans {
            font-family: 'Open Sans', -apple-system, sans-serif;
        }

        .font-option.roboto {
            font-family: Roboto, -apple-system, sans-serif;
        }

        .font-option.arial {
            font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
        }

        .font-option.verdana {
            font-family: Verdana, Geneva, sans-serif;
        }

        .font-option.atkinson {
            font-family: 'Atkinson Hyperlegible', 'Comic Sans MS', sans-serif;
        }

        .spacing-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .spacing-option {
            background: var(--bg-main);
            color: var(--text-primary);
            border: 2px solid var(--border);
            padding: 0.75rem 0.25rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
        }

        .spacing-option:hover {
            background: var(--border);
        }

        .spacing-option.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .alignment-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .alignment-option {
            background: var(--bg-main);
            color: var(--text-primary);
            border: 2px solid var(--border);
            padding: 0.75rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.8125rem;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
        }

        .alignment-option:hover {
            background: var(--border);
        }

        .alignment-option.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .page-mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .page-mode-option {
            background: var(--bg-main);
            color: var(--text-primary);
            border: 2px solid var(--border);
            padding: 0.75rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.8125rem;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
        }

        .page-mode-option:hover {
            background: var(--border);
        }

        .page-mode-option.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Loading Spinner */
        .book-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(4px);
        }

        .book-loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: #06b6d4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .book-loading-text {
            color: white;
            font-size: 0.875rem;
            font-weight: 600;
            margin-top: 0.75rem;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Library View -->
        <div class="library-view active" id="libraryView">
            <div class="library-header">
                <div>
                    <h1 class="library-title">üìö My Library</h1>
                    <p class="library-stats" id="libraryStats">0 books</p>
                </div>
                <div style="position: relative;">
                    <button id="libraryMenuBtn" style="background: var(--bg-card); border: 1px solid var(--border); color: var(--text-primary); padding: 0.75rem 1rem; border-radius: 0.5rem; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem; transition: all 0.2s;">
                        <span>‚ò∞</span>
                    </button>
                    <div id="libraryMenu" style="display: none; position: absolute; top: calc(100% + 0.5rem); right: 0; background: var(--bg-card); border: 1px solid var(--border); border-radius: 0.75rem; min-width: 250px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); z-index: 1000; overflow: hidden;">
                        <div style="padding: 0.5rem;">
                            <button id="menuAddLocal" style="width: 100%; text-align: left; padding: 0.875rem 1rem; background: transparent; border: none; color: var(--text-primary); cursor: pointer; border-radius: 0.5rem; display: flex; align-items: center; gap: 0.75rem; font-size: 1rem; transition: all 0.2s;">
                                <span style="font-size: 1.25rem;">‚ûï</span>
                                <span>Add from Local Storage</span>
                            </button>
                            <button id="menuAddCloud" style="width: 100%; text-align: left; padding: 0.875rem 1rem; background: transparent; border: none; color: var(--text-primary); cursor: pointer; border-radius: 0.5rem; display: flex; align-items: center; gap: 0.75rem; font-size: 1rem; transition: all 0.2s;">
                                <span style="font-size: 1.25rem;">‚òÅÔ∏è</span>
                                <span>Add from Cloud</span>
                            </button>
                            <button id="menuSync" style="width: 100%; text-align: left; padding: 0.875rem 1rem; background: transparent; border: none; color: var(--text-primary); cursor: pointer; border-radius: 0.5rem; display: flex; align-items: center; gap: 0.75rem; font-size: 1rem; transition: all 0.2s;">
                                <span style="font-size: 1.25rem;">üîÑ</span>
                                <span>Sync with Drive</span>
                            </button>
                        </div>
                    </div>
                    <input type="file" id="libraryEpubInput" accept=".epub" style="display: none;" />
                </div>
            </div>
            
            <div class="library-grid" id="libraryGrid">
                <!-- Book cards will be inserted here -->
            </div>
            
            <div class="empty-library" id="emptyLibrary">
                <div class="empty-library-icon">üìñ</div>
                <p class="empty-library-text">Your library is empty</p>
                <p style="color: var(--text-secondary); font-size: 0.875rem;">Add an EPUB book to get started</p>
            </div>
        </div>

        <!-- Reader View -->
        <div class="reader-view" id="readerView">
            <div class="header">
                <div class="header-top">
                    <h1>
                        <span>üìñ</span>
                        <span>EPUB Reader</span>
                    </h1>
                    <div class="header-actions">
                        <button class="icon-btn" id="backToLibraryBtn" title="Back to Library">
                            ‚Üê Library
                        </button>
                    </div>
                </div>
                
                <div class="status-bar" id="statusBar" style="display: none;">
                    <div class="book-info" id="bookInfo">
                        <div class="book-cover" id="bookCover" style="display: none;">
                            <img id="bookCoverImage" alt="Book cover" />
                        </div>
                        <div class="book-details">
                            <div class="book-title" id="bookTitle">Book Title</div>
                            <div class="book-author" id="bookAuthor">Author Name</div>
                            <div class="book-chapter" id="bookChapter">Chapter 1</div>
                        </div>
                    </div>
                </div>

                <div id="debugPanel" class="debug-panel" style="display: none;">
                    <h3>Debug Information</h3>
                    <div id="debugContent"></div>
                </div>
            </div>

            <div class="main-content">
                <div class="reader-area" id="readerArea">
                    <div class="reader-controls">
                        <button class="reader-btn" id="fullscreenBtn" title="Toggle Fullscreen">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="fullscreenIcon">
                                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" fill="currentColor"/>
                            </svg>
                        </button>
                        <button class="reader-btn" id="settingsBtn" title="Settings">
                            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 15a3 3 0 100-6 3 3 0 000 6z" fill="currentColor"/>
                                <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z" fill="currentColor"/>
                            </svg>
                        </button>
                    </div>
                    <div class="page-navigation" id="pageNavigation">
                        <button class="page-nav-btn" id="prevPageBtn" disabled>‚óÄ</button>
                        <div class="page-info" id="pageInfo">Page 1</div>
                        <button class="page-nav-btn" id="nextPageBtn">‚ñ∂</button>
                    </div>
                    <div id="viewer"></div>
                </div>
            </div>

            <div class="controls-panel">
                <div class="controls-main">
                    <button class="btn btn-icon-circular" id="prevBtn" disabled>
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
                            <path d="M14 8l-4 4 4 4M10 12h4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                            <rect x="8" y="8" width="1.5" height="8" fill="currentColor"/>
                        </svg>
                    </button>
                    <button class="btn btn-play" id="playBtn" disabled>
                        <span class="btn-icon">‚ñ∂</span>
                    </button>
                    <button class="btn btn-icon-circular" id="nextBtn" disabled>
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
                            <path d="M10 8l4 4-4 4M14 12h-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
                            <rect x="14.5" y="8" width="1.5" height="8" fill="currentColor"/>
                        </svg>
                    </button>
                </div>

                <div class="controls-main">
                    <div class="speed-control">
                        <button class="speed-btn" data-speed="0.5">0.5x</button>
                        <button class="speed-btn" data-speed="0.75">0.75x</button>
                        <button class="speed-btn active" data-speed="1">1x</button>
                        <button class="speed-btn" data-speed="1.25">1.25x</button>
                        <button class="speed-btn" data-speed="1.5">1.5x</button>
                        <button class="speed-btn" data-speed="2">2x</button>
                    </div>
                    <input type="range" id="speedSlider" min="0.5" max="2" step="0.1" value="1" />
                    <span id="speedDisplay">1.0x</span>
                </div>

                <div class="controls-main">
                    <button class="btn" id="chaptersBtn" disabled style="width: auto; padding: 0.75rem 1.5rem; border-radius: 12px;">
                        <span style="margin-right: 0.5rem;">üìë</span>
                        <span>Table of Contents</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <script>
        console.log('=== EPUB Reader Starting ===');
        
        // Google Drive Sync Manager
        class GoogleDriveSyncManager {
            constructor() {
                this.CLIENT_ID = 'YOUR_CLIENT_ID'; // User needs to set this
                this.API_KEY = 'YOUR_API_KEY'; // User needs to set this
                this.DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
                this.SCOPES = 'https://www.googleapis.com/auth/drive.file';
                this.SYNC_FILENAME = 'epub-reader-library.json';
                
                this.tokenClient = null;
                this.accessToken = null;
                this.tokenExpiresAt = null;
                this.gapiInited = false;
                this.gisInited = false;
                this.fileId = null;
                
                // Auto-sync settings
                this.autoSyncEnabled = localStorage.getItem('auto_sync_enabled') === 'true';
                this.syncInterval = null;
                this.lastSyncTime = localStorage.getItem('last_sync_time');
                
                // Load saved authentication
                this.loadSavedAuth();
            }

            loadSavedAuth() {
                try {
                    const savedToken = localStorage.getItem('gdrive_access_token');
                    const savedExpiry = localStorage.getItem('gdrive_token_expiry');
                    
                    if (savedToken && savedExpiry) {
                        const expiryTime = parseInt(savedExpiry);
                        const now = Date.now();
                        
                        // Check if token is still valid (with 5 minute buffer)
                        if (expiryTime > now + (5 * 60 * 1000)) {
                            this.accessToken = savedToken;
                            this.tokenExpiresAt = expiryTime;
                            console.log('‚úì Restored saved Google Drive authentication');
                        } else {
                            console.log('Saved token expired, will request new one');
                            this.clearSavedAuth();
                        }
                    }
                } catch (error) {
                    console.error('Error loading saved auth:', error);
                    this.clearSavedAuth();
                }
            }

            saveAuth(accessToken, expiresIn) {
                try {
                    // expiresIn is in seconds, convert to milliseconds and add to current time
                    const expiryTime = Date.now() + (expiresIn * 1000);
                    
                    localStorage.setItem('gdrive_access_token', accessToken);
                    localStorage.setItem('gdrive_token_expiry', expiryTime.toString());
                    
                    this.accessToken = accessToken;
                    this.tokenExpiresAt = expiryTime;
                    
                    console.log('‚úì Saved Google Drive authentication');
                } catch (error) {
                    console.error('Error saving auth:', error);
                }
            }

            clearSavedAuth() {
                localStorage.removeItem('gdrive_access_token');
                localStorage.removeItem('gdrive_token_expiry');
                this.accessToken = null;
                this.tokenExpiresAt = null;
            }

            isTokenValid() {
                if (!this.accessToken || !this.tokenExpiresAt) {
                    return false;
                }
                
                // Check if token expires in more than 5 minutes
                return this.tokenExpiresAt > Date.now() + (5 * 60 * 1000);
            }

            async initialize() {
                // Check if user has configured API credentials
                const storedClientId = localStorage.getItem('gdrive_client_id');
                const storedApiKey = localStorage.getItem('gdrive_api_key');
                
                if (storedClientId) this.CLIENT_ID = storedClientId;
                if (storedApiKey) this.API_KEY = storedApiKey;
                
                // Load the file ID if we've synced before
                this.fileId = localStorage.getItem('gdrive_sync_file_id');
                
                // Initialize Google APIs
                await this.initializeGoogleAPIs();
            }

            async initializeGoogleAPIs() {
                return new Promise((resolve) => {
                    // Wait for gapi to load
                    const checkGapi = setInterval(() => {
                        if (typeof gapi !== 'undefined') {
                            clearInterval(checkGapi);
                            gapi.load('client', async () => {
                                await gapi.client.init({
                                    apiKey: this.API_KEY,
                                    discoveryDocs: [this.DISCOVERY_DOC],
                                });
                                this.gapiInited = true;
                                resolve();
                            });
                        }
                    }, 100);
                    
                    // Wait for google.accounts to load
                    const checkGis = setInterval(() => {
                        if (typeof google !== 'undefined' && google.accounts) {
                            clearInterval(checkGis);
                            this.tokenClient = google.accounts.oauth2.initTokenClient({
                                client_id: this.CLIENT_ID,
                                scope: this.SCOPES,
                                callback: '', // defined later
                            });
                            this.gisInited = true;
                        }
                    }, 100);
                });
            }

            async requestAccessToken() {
                return new Promise((resolve, reject) => {
                    try {
                        // Check if we have a valid saved token first
                        if (this.isTokenValid()) {
                            console.log('‚úì Using saved Google Drive token');
                            resolve({ access_token: this.accessToken });
                            return;
                        }
                        
                        this.tokenClient.callback = (response) => {
                            if (response.error !== undefined) {
                                reject(response);
                            } else {
                                this.accessToken = response.access_token;
                                
                                // Save token with expiration (default 3600 seconds = 1 hour)
                                const expiresIn = response.expires_in || 3600;
                                this.saveAuth(response.access_token, expiresIn);
                                
                                console.log('‚úì New Google Drive token obtained and saved');
                                resolve(response);
                            }
                        };
                        
                        // Request new token
                        console.log('Requesting new Google Drive token...');
                        if (this.accessToken === null) {
                            // First time - show full consent screen
                            this.tokenClient.requestAccessToken({ prompt: 'consent' });
                        } else {
                            // Try to refresh silently first
                            this.tokenClient.requestAccessToken({ prompt: '' });
                        }
                    } catch (err) {
                        reject(err);
                    }
                });
            }

            async syncToGoogleDrive(libraryData) {
                try {
                    if (!this.gapiInited || !this.gisInited) {
                        throw new Error('Google Drive API not initialized');
                    }

                    // Check if token is valid, request new one if needed
                    if (!this.isTokenValid()) {
                        await this.requestAccessToken();
                    }

                    // Prepare sync data with metadata for each book
                    const booksWithMetadata = libraryData.map(book => ({
                        ...book,
                        syncedAt: new Date().toISOString(),
                        deleted: false // Mark as not deleted
                    }));

                    // Get deleted books from localStorage
                    const deletedBooks = JSON.parse(localStorage.getItem('deleted_books') || '[]');

                    const dataToSync = {
                        books: booksWithMetadata,
                        deletedBooks: deletedBooks, // Track deleted books
                        lastSync: new Date().toISOString(),
                        deviceId: this.getDeviceId(),
                        version: 2 // Increment version for new sync format
                    };

                    const content = JSON.stringify(dataToSync, null, 2);
                    const blob = new Blob([content], { type: 'application/json' });

                    // If we don't have a file ID, try to find existing file
                    if (!this.fileId) {
                        console.log('No file ID stored, searching for existing sync file...');
                        this.fileId = await this.findSyncFile();
                        if (this.fileId) {
                            console.log(`‚úì Found existing sync file: ${this.fileId}`);
                            localStorage.setItem('gdrive_sync_file_id', this.fileId);
                        }
                    }

                    // Check if file already exists
                    if (this.fileId) {
                        // Update existing file
                        console.log(`Updating existing sync file: ${this.fileId}`);
                        await this.updateFile(this.fileId, blob);
                    } else {
                        // Create new file only if none exists
                        console.log('Creating new sync file...');
                        this.fileId = await this.createFile(blob);
                        localStorage.setItem('gdrive_sync_file_id', this.fileId);
                        console.log(`‚úì Created new sync file: ${this.fileId}`);
                    }

                    // Update last sync time
                    this.lastSyncTime = new Date().toISOString();
                    localStorage.setItem('last_sync_time', this.lastSyncTime);

                    return { success: true, message: 'Synced to Google Drive!' };
                } catch (error) {
                    console.error('Sync error:', error);
                    
                    // If authentication error, clear saved auth and try again
                    if (error.message && (error.message.includes('401') || error.message.includes('403'))) {
                        console.log('Authentication error, clearing saved token');
                        this.clearSavedAuth();
                    }
                    
                    return { success: false, error: error.message };
                }
            }

            getDeviceId() {
                // Get or create a unique device ID
                let deviceId = localStorage.getItem('device_id');
                if (!deviceId) {
                    deviceId = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    localStorage.setItem('device_id', deviceId);
                }
                return deviceId;
            }

            mergeLibraries(localBooks, remoteBooks, remoteDeletedBooks = []) {
                console.log(`üîÑ Merging libraries: ${localBooks.length} local books, ${remoteBooks.length} remote books, ${remoteDeletedBooks.length} deleted books`);
                
                // Create a map of remote books by ID for quick lookup
                const remoteBookMap = new Map(remoteBooks.map(book => [book.id, book]));
                const remoteDeletedIds = new Set(remoteDeletedBooks.map(b => b.id));
                const localBookMap = new Map(localBooks.map(book => [book.id, book]));
                
                const mergedBooks = [];
                const seenIds = new Set();

                // Process local books
                for (const localBook of localBooks) {
                    seenIds.add(localBook.id);
                    
                    // If book was deleted remotely, skip it
                    if (remoteDeletedIds.has(localBook.id)) {
                        console.log(`‚ùå Removing "${localBook.title}" (deleted on another device)`);
                        continue;
                    }

                    // If book exists remotely, merge it
                    if (remoteBookMap.has(localBook.id)) {
                        const remoteBook = remoteBookMap.get(localBook.id);
                        
                        // Merge using the most recent data
                        const mergedBook = this.mergeBookData(localBook, remoteBook);
                        mergedBooks.push(mergedBook);
                    } else {
                        // Local-only book, keep it
                        console.log(`üì± Keeping local-only book: "${localBook.title}"`);
                        mergedBooks.push(localBook);
                    }
                }

                // Add remote books that don't exist locally
                for (const remoteBook of remoteBooks) {
                    if (!seenIds.has(remoteBook.id) && !remoteDeletedIds.has(remoteBook.id)) {
                        console.log(`‚òÅÔ∏è Adding remote book: "${remoteBook.title}"`);
                        mergedBooks.push(remoteBook);
                    }
                }

                console.log(`‚úì Merge complete: ${mergedBooks.length} books in final library`);
                return mergedBooks;
            }

            mergeBookData(localBook, remoteBook) {
                // Use the most recent progress
                const localLastRead = new Date(localBook.lastRead || 0).getTime();
                const remoteLastRead = new Date(remoteBook.lastRead || 0).getTime();
                
                // Start with local book data
                const merged = { ...localBook };
                
                // If remote is more recent, use remote progress
                if (remoteLastRead > localLastRead) {
                    console.log(`Using remote progress for ${localBook.title} (remote: ${new Date(remoteLastRead).toLocaleString()}, local: ${new Date(localLastRead).toLocaleString()})`);
                    merged.progress = remoteBook.progress;
                    merged.lastRead = remoteBook.lastRead;
                    merged.syncedAt = remoteBook.syncedAt;
                } else if (localLastRead > remoteLastRead) {
                    // Local is more recent, keep local progress
                    console.log(`Keeping local progress for ${localBook.title} (local: ${new Date(localLastRead).toLocaleString()}, remote: ${new Date(remoteLastRead).toLocaleString()})`);
                    merged.syncedAt = new Date().toISOString();
                } else {
                    // Same time or no timestamps, keep local but update sync time
                    console.log(`No difference in progress for ${localBook.title}`);
                    merged.syncedAt = new Date().toISOString();
                }
                
                return merged;
            }

            async syncFromGoogleDrive() {
                try {
                    if (!this.gapiInited || !this.gisInited) {
                        throw new Error('Google Drive API not initialized');
                    }

                    // Check if token is valid, request new one if needed
                    if (!this.isTokenValid()) {
                        await this.requestAccessToken();
                    }

                    // Find the sync file
                    if (!this.fileId) {
                        this.fileId = await this.findSyncFile();
                        if (this.fileId) {
                            localStorage.setItem('gdrive_sync_file_id', this.fileId);
                        }
                    }

                    if (!this.fileId) {
                        return { success: false, error: 'No sync file found in Google Drive', needsFirstSync: true };
                    }

                    // Download the file
                    try {
                        const response = await gapi.client.drive.files.get({
                            fileId: this.fileId,
                            alt: 'media'
                        });

                        const syncData = JSON.parse(response.body);
                        
                        return { 
                            success: true, 
                            data: syncData.books, 
                            deletedBooks: syncData.deletedBooks || [],
                            lastSync: syncData.lastSync,
                            version: syncData.version || 1
                        };
                    } catch (fileError) {
                        // Check if it's a 404 (file not found)
                        if (fileError.status === 404 || (fileError.result && fileError.result.error && fileError.result.error.code === 404)) {
                            console.warn('Sync file not found (404), clearing stored file ID');
                            // Clear the invalid file ID
                            this.fileId = null;
                            localStorage.removeItem('gdrive_sync_file_id');
                            return { 
                                success: false, 
                                error: 'Sync file not found. It may have been deleted. Create a new sync file by uploading your library.',
                                needsFirstSync: true,
                                errorCode: 404
                            };
                        }
                        throw fileError;
                    }
                } catch (error) {
                    console.error('Sync from Drive error:', error);
                    
                    // Check for authentication errors
                    if (error.status === 401 || error.status === 403) {
                        this.clearSavedAuth();
                        return { 
                            success: false, 
                            error: 'Authentication expired. Please sign in again.',
                            needsAuth: true
                        };
                    }
                    
                    return { success: false, error: error.message || 'Unknown error occurred' };
                }
            }

            async createFile(blob) {
                const metadata = {
                    name: this.SYNC_FILENAME,
                    mimeType: 'application/json',
                };

                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', blob);

                const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST',
                    headers: new Headers({ 'Authorization': 'Bearer ' + this.accessToken }),
                    body: form,
                });

                const result = await response.json();
                return result.id;
            }

            async updateFile(fileId, blob) {
                const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
                    method: 'PATCH',
                    headers: new Headers({
                        'Authorization': 'Bearer ' + this.accessToken,
                        'Content-Type': 'application/json'
                    }),
                    body: blob,
                });

                return await response.json();
            }

            async findSyncFile() {
                const response = await gapi.client.drive.files.list({
                    q: `name='${this.SYNC_FILENAME}' and trashed=false`,
                    spaces: 'drive',
                    fields: 'files(id, name)',
                });

                const files = response.result.files;
                if (files && files.length > 0) {
                    return files[0].id;
                }
                return null;
            }

            isConfigured() {
                return this.CLIENT_ID !== 'YOUR_CLIENT_ID' && this.API_KEY !== 'YOUR_API_KEY';
            }

            showConfigDialog() {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 1rem;
                `;

                modal.innerHTML = `
                    <div style="background: #1e293b; border-radius: 1rem; padding: 2rem; max-width: 600px; width: 100%; color: #f8fafc;">
                        <h2 style="margin-bottom: 1rem; font-size: 1.5rem;">Configure Google Drive Sync</h2>
                        <p style="margin-bottom: 1.5rem; color: #cbd5e1; font-size: 0.875rem;">
                            To enable Google Drive sync, you need to create a Google Cloud project and get API credentials.
                        </p>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Client ID:</label>
                            <input type="text" id="clientIdInput" placeholder="Your Google Client ID" 
                                style="width: 100%; padding: 0.75rem; background: #0f172a; border: 1px solid #334155; border-radius: 0.5rem; color: #f8fafc; font-family: monospace; font-size: 0.875rem;" />
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">API Key:</label>
                            <input type="text" id="apiKeyInput" placeholder="Your Google API Key" 
                                style="width: 100%; padding: 0.75rem; background: #0f172a; border: 1px solid #334155; border-radius: 0.5rem; color: #f8fafc; font-family: monospace; font-size: 0.875rem;" />
                        </div>
                        
                        <details style="margin-bottom: 1.5rem; padding: 1rem; background: #0f172a; border-radius: 0.5rem;">
                            <summary style="cursor: pointer; font-weight: 600; color: #3b82f6;">How to get API credentials</summary>
                            <ol style="margin-top: 1rem; padding-left: 1.5rem; color: #cbd5e1; font-size: 0.875rem; line-height: 1.6;">
                                <li>Go to <a href="https://console.cloud.google.com" target="_blank" style="color: #3b82f6;">Google Cloud Console</a></li>
                                <li>Create a new project or select existing one</li>
                                <li>Enable "Google Drive API"</li>
                                <li>Go to "Credentials" and create:
                                    <ul style="margin-top: 0.5rem; padding-left: 1rem;">
                                        <li>OAuth 2.0 Client ID (Web application)</li>
                                        <li>API Key</li>
                                    </ul>
                                </li>
                                <li>Add your domain to authorized origins</li>
                            </ol>
                        </details>
                        
                        <div style="display: flex; gap: 0.5rem;">
                            <button id="saveConfigBtn" style="flex: 1; background: #10b981; color: white; border: none; padding: 0.75rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">
                                Save & Enable Sync
                            </button>
                            <button id="cancelConfigBtn" style="background: #334155; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                const clientIdInput = modal.querySelector('#clientIdInput');
                const apiKeyInput = modal.querySelector('#apiKeyInput');
                
                // Load saved values if they exist
                clientIdInput.value = localStorage.getItem('gdrive_client_id') || '';
                apiKeyInput.value = localStorage.getItem('gdrive_api_key') || '';

                modal.querySelector('#saveConfigBtn').addEventListener('click', () => {
                    const clientId = clientIdInput.value.trim();
                    const apiKey = apiKeyInput.value.trim();

                    if (!clientId || !apiKey) {
                        alert('Please enter both Client ID and API Key');
                        return;
                    }

                    localStorage.setItem('gdrive_client_id', clientId);
                    localStorage.setItem('gdrive_api_key', apiKey);
                    
                    this.CLIENT_ID = clientId;
                    this.API_KEY = apiKey;
                    
                    modal.remove();
                    alert('Configuration saved! Please refresh the page to enable sync.');
                    location.reload();
                });

                modal.querySelector('#cancelConfigBtn').addEventListener('click', () => {
                    modal.remove();
                });
            }

            enableAutoSync() {
                this.autoSyncEnabled = true;
                localStorage.setItem('auto_sync_enabled', 'true');
            }

            disableAutoSync() {
                this.autoSyncEnabled = false;
                localStorage.setItem('auto_sync_enabled', 'false');
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
            }

            startAutoSync(libraryManager) {
                if (!this.autoSyncEnabled || !this.isConfigured()) {
                    return;
                }

                // Sync every 5 minutes - UPLOAD ONLY
                this.syncInterval = setInterval(async () => {
                    console.log('Auto-syncing (upload only)...');
                    
                    try {
                        const books = libraryManager.getAllBooks();
                        const result = await this.syncToGoogleDrive(books);
                        
                        if (result.success) {
                            console.log('‚úì Auto-sync successful (uploaded)');
                        } else {
                            console.error('Auto-sync failed:', result.error);
                        }
                    } catch (error) {
                        console.error('Auto-sync error:', error);
                    }
                }, 5 * 60 * 1000); // 5 minutes
            }

            async performInitialSync(libraryManager) {
                if (!this.autoSyncEnabled || !this.isConfigured()) {
                    return { skipped: true };
                }

                try {
                    // On app startup, ALWAYS download from Google Drive first
                    console.log('Performing initial sync (download from Drive)...');
                    const downloadResult = await this.syncFromGoogleDrive();
                    
                    if (downloadResult.success) {
                        // Successfully downloaded from Drive
                        console.log('‚úì Downloaded library from Google Drive');
                        
                        // Merge remote data with local (smart merge)
                        const localBooks = libraryManager.getAllBooks();
                        const remoteBooks = downloadResult.data || [];
                        const remoteDeletedBooks = downloadResult.deletedBooks || [];
                        
                        const mergedBooks = this.mergeLibraries(
                            localBooks,
                            remoteBooks,
                            remoteDeletedBooks
                        );
                        
                        return { 
                            success: true, 
                            action: 'downloaded',
                            data: mergedBooks,
                            lastSync: downloadResult.lastSync
                        };
                    } else {
                        // No remote file exists yet, upload local data to create it
                        const localBooks = libraryManager.getAllBooks();
                        if (localBooks.length > 0) {
                            console.log('No remote file found, uploading local library to Google Drive');
                            await this.syncToGoogleDrive(localBooks);
                            return { success: true, action: 'uploaded' };
                        } else {
                            console.log('No books to sync');
                            return { success: true, action: 'none' };
                        }
                    }
                } catch (error) {
                    console.error('Initial sync error:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // Library Manager
        class LibraryManager {
            constructor() {
                this.books = [];
                this.loadFromStorage();
            }

            loadFromStorage() {
                try {
                    const stored = localStorage.getItem('epubLibrary');
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        // Ensure it's an array
                        if (Array.isArray(parsed)) {
                            this.books = parsed;
                        } else {
                            console.warn('Stored library data is not an array, resetting');
                            this.books = [];
                            this.saveToStorage();
                        }
                    }
                } catch (error) {
                    console.error('Error loading library:', error);
                    this.books = [];
                    // Clear corrupted data
                    localStorage.removeItem('epubLibrary');
                }
            }

            saveToStorage() {
                try {
                    // Ensure books is an array before saving
                    if (!Array.isArray(this.books)) {
                        console.error('Books is not an array, cannot save');
                        this.books = [];
                    }
                    
                    const dataToSave = JSON.stringify(this.books);
                    localStorage.setItem('epubLibrary', dataToSave);
                    
                } catch (error) {
                    console.error('Error saving library:', error);
                    
                    // If quota exceeded, try emergency cleanup
                    if (error.name === 'QuotaExceededError') {
                        console.log('Storage quota exceeded, attempting cleanup...');
                        
                        // Remove all cached book data and try again
                        this.books.forEach(book => {
                            delete book.fileData;
                            book.isCached = false;
                        });
                        
                        try {
                            const cleanedData = JSON.stringify(this.books);
                            localStorage.setItem('epubLibrary', cleanedData);
                            console.log('Successfully saved after removing cached book data');
                            throw new Error('Storage full - removed cached book data to save library');
                        } catch (secondError) {
                            // If still failing, try removing cover images
                            this.books.forEach(book => {
                                delete book.coverImage;
                            });
                            
                            try {
                                const minimalData = JSON.stringify(this.books);
                                localStorage.setItem('epubLibrary', minimalData);
                                console.log('Successfully saved after removing covers and cached data');
                                throw new Error('Storage critically full - removed covers to save library');
                            } catch (thirdError) {
                                console.error('Could not save even minimal library data');
                                throw new Error('Storage quota exceeded - cannot save library');
                            }
                        }
                    } else {
                        throw error;
                    }
                }
            }

            addBook(bookData, cacheFileData = false) {
                // Ensure books is an array
                if (!Array.isArray(this.books)) {
                    console.warn('Books was not an array, resetting');
                    this.books = [];
                }
                
                // Check if book already exists
                const existingIndex = this.books.findIndex(b => b.id === bookData.id);
                const existingBook = existingIndex !== -1 ? this.books[existingIndex] : null;
                
                // If we're caching this book's file data, clear file data from all other books
                if (cacheFileData && bookData.fileData) {
                    this.books.forEach(book => {
                        if (book.id !== bookData.id) {
                            delete book.fileData;
                        }
                    });
                }
                
                // Create book entry - only include fileData if caching
                const bookEntry = {
                    id: bookData.id,
                    title: bookData.title,
                    author: bookData.author,
                    coverImage: bookData.coverImage,
                    filePath: bookData.filePath || (existingBook ? existingBook.filePath : null),
                    fileMetadata: bookData.fileMetadata || (existingBook ? existingBook.fileMetadata : null),
                    hasMediaOverlay: bookData.hasMediaOverlay !== undefined ? bookData.hasMediaOverlay : (existingBook ? existingBook.hasMediaOverlay : false),
                    addedDate: bookData.addedDate || (existingBook ? existingBook.addedDate : new Date().toISOString()),
                    lastRead: bookData.lastRead || (existingBook ? existingBook.lastRead : null),
                    // IMPORTANT: Preserve existing progress if book exists, otherwise use provided progress
                    progress: existingBook && existingBook.progress ? existingBook.progress : (bookData.progress || {
                        chapterIndex: 0,
                        segmentIndex: 0,
                        percentage: 0
                    }),
                    source: bookData.source || (existingBook ? existingBook.source : 'local'),
                    cloudUrl: bookData.cloudUrl || (existingBook ? existingBook.cloudUrl : null)
                };
                
                // Only include file data if explicitly caching
                if (cacheFileData && bookData.fileData) {
                    bookEntry.fileData = bookData.fileData;
                    bookEntry.isCached = true;
                } else {
                    bookEntry.isCached = false;
                }
                
                if (existingIndex !== -1) {
                    // Update existing book
                    this.books[existingIndex] = bookEntry;
                } else {
                    // Add new book
                    this.books.push(bookEntry);
                }
                
                this.saveToStorage();
            }

            removeBook(bookId) {
                if (!Array.isArray(this.books)) {
                    this.books = [];
                    return;
                }
                
                // Find the book before removing it
                const book = this.books.find(b => b.id === bookId);
                
                // Remove from books array
                this.books = this.books.filter(b => b.id !== bookId);
                this.saveToStorage();
                
                // Track deletion for sync
                if (book) {
                    const deletedBooks = JSON.parse(localStorage.getItem('deleted_books') || '[]');
                    deletedBooks.push({
                        id: book.id,
                        title: book.title,
                        deletedAt: new Date().toISOString()
                    });
                    
                    // Keep only last 100 deletions to avoid storage bloat
                    if (deletedBooks.length > 100) {
                        deletedBooks.splice(0, deletedBooks.length - 100);
                    }
                    
                    localStorage.setItem('deleted_books', JSON.stringify(deletedBooks));
                    console.log(`Tracked deletion of: ${book.title}`);
                }
            }

            getBook(bookId) {
                if (!Array.isArray(this.books)) {
                    this.books = [];
                    return null;
                }
                return this.books.find(b => b.id === bookId);
            }

            updateProgress(bookId, progress) {
                const book = this.getBook(bookId);
                if (book) {
                    book.progress = progress;
                    book.lastRead = new Date().toISOString();
                    this.saveToStorage();
                }
            }

            // Cache a book's file data (removes file data from other books)
            cacheBookData(bookId, fileData) {
                if (!Array.isArray(this.books)) {
                    this.books = [];
                    return;
                }
                
                // Remove fileData from all books
                this.books.forEach(book => {
                    if (book.id !== bookId) {
                        delete book.fileData;
                        book.isCached = false;
                    }
                });
                
                // Add fileData to the specified book
                const book = this.getBook(bookId);
                if (book) {
                    book.fileData = fileData;
                    book.isCached = true;
                    book.lastRead = new Date().toISOString();
                    this.saveToStorage();
                }
            }

            getAllBooks() {
                // Ensure books is an array
                if (!Array.isArray(this.books)) {
                    console.warn('Books is not an array, resetting');
                    this.books = [];
                    return [];
                }
                
                // Sort by last read date
                return [...this.books].sort((a, b) => 
                    new Date(b.lastRead || b.addedDate) - new Date(a.lastRead || a.addedDate)
                );
            }
        }

        // SMIL Parser
        class SMILParser {
            constructor() {
                this.segments = [];
            }

            async parse(smilContent) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(smilContent, 'text/xml');
                
                const parserError = xmlDoc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('SMIL parsing error');
                }

                const segments = [];
                const parElements = xmlDoc.querySelectorAll('par');
                
                parElements.forEach((par, index) => {
                    const textElement = par.querySelector('text');
                    const audioElement = par.querySelector('audio');
                    
                    if (textElement && audioElement) {
                        segments.push({
                            id: par.getAttribute('id') || `segment-${index}`,
                            textSrc: textElement.getAttribute('src'),
                            audioSrc: audioElement.getAttribute('src'),
                            clipBegin: this.parseTime(audioElement.getAttribute('clipBegin') || '0'),
                            clipEnd: this.parseTime(audioElement.getAttribute('clipEnd') || '0')
                        });
                    }
                });
                
                this.segments = segments;
                return segments;
            }

            parseTime(timeStr) {
                if (!timeStr) return 0;
                
                if (timeStr.endsWith('ms')) return parseFloat(timeStr) / 1000;
                if (timeStr.endsWith('s')) return parseFloat(timeStr);
                
                const parts = timeStr.split(':');
                if (parts.length === 3) {
                    return parseFloat(parts[0]) * 3600 + 
                           parseFloat(parts[1]) * 60 + 
                           parseFloat(parts[2]);
                }
                if (parts.length === 2) {
                    return parseFloat(parts[0]) * 60 + parseFloat(parts[1]);
                }
                
                return parseFloat(timeStr) || 0;
            }
        }

        // Media Overlay Controller
        class MediaOverlayController {
            constructor(onSegmentChange, onPlaybackEnd) {
                this.audioCache = new Map();
                this.currentAudio = null;
                this.currentSegment = null;
                this.allSegments = [];
                this.currentSegmentIndex = 0;
                this.isPlaying = false;
                this.onSegmentChange = onSegmentChange;
                this.onPlaybackEnd = onPlaybackEnd;
                this.playbackRate = 1.0;
                this.monitorInterval = null;
            }

            setSegments(segments) {
                this.allSegments = segments;
                this.currentSegmentIndex = 0;
            }

            async loadSegment(segment, audioBaseUrl = '', blobUrl = null) {
                this.currentSegment = segment;
                
                let audioUrl = blobUrl || segment.audioSrc;
                
                if (this.audioCache.has(audioUrl)) {
                    this.currentAudio = this.audioCache.get(audioUrl);
                    this.currentAudio.currentTime = segment.clipBegin;
                    this.currentAudio.playbackRate = this.playbackRate;
                    return Promise.resolve();
                }
                
                const audio = new Audio();
                this.currentAudio = audio;
                this.audioCache.set(audioUrl, audio);
                
                return new Promise((resolve, reject) => {
                    const metadataHandler = () => {
                        if (segment.clipBegin > audio.duration) {
                            reject(new Error(`Clip begin (${segment.clipBegin}s) is beyond audio duration (${audio.duration}s)`));
                            return;
                        }
                        
                        audio.currentTime = segment.clipBegin;
                        resolve();
                    };
                    
                    const errorHandler = (e) => {
                        const errorMessages = {
                            1: 'MEDIA_ERR_ABORTED',
                            2: 'MEDIA_ERR_NETWORK',
                            3: 'MEDIA_ERR_DECODE',
                            4: 'MEDIA_ERR_SRC_NOT_SUPPORTED'
                        };
                        
                        const errorMsg = audio.error ? 
                            errorMessages[audio.error.code] || audio.error.message :
                            'Unknown error';
                        
                        reject(new Error(`Audio error: ${errorMsg}`));
                    };
                    
                    audio.addEventListener('loadedmetadata', metadataHandler, { once: true });
                    audio.addEventListener('error', errorHandler, { once: true });
                    
                    audio.src = audioUrl;
                    audio.playbackRate = this.playbackRate;
                    audio.load();
                });
            }

            play() {
                if (!this.currentSegment || !this.currentAudio) return;
                this.isPlaying = true;
                
                const playPromise = this.currentAudio.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error('Play error:', error);
                        this.isPlaying = false;
                    });
                }
                
                this.startMonitoring();
            }

            pause() {
                this.isPlaying = false;
                if (this.currentAudio) {
                    this.currentAudio.pause();
                }
                this.stopMonitoring();
            }

            stop() {
                this.pause();
                if (this.currentAudio) {
                    this.currentAudio.currentTime = 0;
                }
            }

            setPlaybackRate(rate) {
                this.playbackRate = rate;
                if (this.currentAudio) {
                    this.currentAudio.playbackRate = rate;
                }
                for (const audio of this.audioCache.values()) {
                    audio.playbackRate = rate;
                }
            }

            startMonitoring() {
                this.stopMonitoring();
                this.monitorInterval = setInterval(() => {
                    if (!this.isPlaying || !this.currentSegment || !this.currentAudio) return;
                    
                    const currentTime = this.currentAudio.currentTime;
                    
                    if (currentTime >= this.currentSegment.clipEnd) {
                        const nextSegmentIndex = this.currentSegmentIndex + 1;
                        if (nextSegmentIndex < this.allSegments.length) {
                            const nextSegment = this.allSegments[nextSegmentIndex];
                            
                            if (nextSegment.audioSrc === this.currentSegment.audioSrc) {
                                this.currentSegment = nextSegment;
                                this.currentSegmentIndex = nextSegmentIndex;
                                if (this.onSegmentChange) {
                                    this.onSegmentChange(nextSegment);
                                }
                                return;
                            }
                        }
                        
                        this.pause();
                        if (this.onPlaybackEnd) {
                            this.onPlaybackEnd();
                        }
                    }
                }, 50);
            }

            stopMonitoring() {
                if (this.monitorInterval) {
                    clearInterval(this.monitorInterval);
                    this.monitorInterval = null;
                }
            }

            handleError(error) {
                console.error('Audio error:', error);
                this.isPlaying = false;
                this.stopMonitoring();
            }

            getCurrentTime() {
                return this.currentAudio ? this.currentAudio.currentTime : 0;
            }

            getDuration() {
                return this.currentSegment ? 
                    this.currentSegment.clipEnd - this.currentSegment.clipBegin : 0;
            }

            clearCache() {
                for (const audio of this.audioCache.values()) {
                    audio.pause();
                    audio.src = '';
                }
                this.audioCache.clear();
                this.currentAudio = null;
            }
        }

        // Main Application
        class EPUBMediaOverlayApp {
            constructor() {
                console.log('Initializing EPUB Reader App');
                this.libraryManager = new LibraryManager();
                this.syncManager = new GoogleDriveSyncManager();
                this.book = null;
                this.currentBookId = null;
                this.parser = new SMILParser();
                this.controller = null;
                this.segments = [];
                this.currentSegmentIndex = 0;
                this.isPlaying = false;
                this.currentChapter = null;
                this.overlayChapters = [];
                this.debugInfo = [];
                this.audioBlobUrls = new Map();
                this.isFullscreen = false;
                this.isDarkMode = false;
                this.wakeLock = null;
                this.isWakeLockEnabled = false;
                this.sleepTimer = null;
                this.sleepTimerMinutes = 0;
                this.sleepTimerEndTime = null;
                this.hasMediaOverlay = false;
                this.rendition = null;
                this.bookMetadata = {
                    title: 'EPUB Book',
                    author: 'Unknown Author',
                    coverImage: null
                };
                
                // Initialize sync manager
                this.syncManager.initialize().catch(err => {
                    console.log('Sync manager init:', err);
                });
                this.initController();
                this.initUI();
                this.bindEvents();
                this.initMediaSession();
                this.clearCachedBooksOnStartup();
                this.renderLibrary();
                
                // Initialize page mode properties
                this.pageMode = localStorage.getItem('pageMode') || 'paginated';
                this.currentPage = 0;
                this.totalPages = 0;
                this.pageContent = [];
                
                // Perform initial sync and start auto-sync
                this.performInitialSyncAndStart();
                
                console.log('App initialized successfully');
            }

            async performInitialSyncAndStart() {
                // Wait a bit for the app to fully load
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                if (this.syncManager.autoSyncEnabled && this.syncManager.isConfigured()) {
                    console.log('Auto-sync enabled, performing initial sync...');
                    
                    const result = await this.syncManager.performInitialSync(this.libraryManager);
                    
                    if (result.success && result.action === 'downloaded') {
                        // Replace local library with merged data
                        this.libraryManager.books = [];
                        result.data.forEach(book => {
                            this.libraryManager.addBook(book, false);
                        });
                        this.renderLibrary();
                        this.showNotification('‚úì Library synced from Google Drive', 'success');
                    } else if (result.success && result.action === 'uploaded') {
                        this.showNotification('‚úì Library uploaded to Google Drive', 'success');
                    }
                    
                    // Start periodic auto-sync (uploads only)
                    this.syncManager.startAutoSync(this.libraryManager);
                    console.log('Auto-sync started (uploads every 5 minutes)');
                }
            }

            clearCachedBooksOnStartup() {
                // Clear all cached file data on app startup to avoid stale data issues
                // Users will need to re-upload local books or re-download cloud books
                if (!Array.isArray(this.libraryManager.books)) {
                    return;
                }
                
                this.libraryManager.books.forEach(book => {
                    if (book.fileData) {
                        delete book.fileData;
                        book.isCached = false;
                    }
                });
                
                this.libraryManager.saveToStorage();
                console.log('Cleared cached book data on startup');
            }

            initMediaSession() {
                if ('mediaSession' in navigator) {
                    console.log('Media Session API available');
                } else {
                    console.log('Media Session API not available');
                }
                
                if ('wakeLock' in navigator) {
                    console.log('Screen Wake Lock API available');
                } else {
                    console.log('Screen Wake Lock API not available');
                    // Hide wake lock button if not supported
                    if (this.elements.wakeLockBtn) {
                        this.elements.wakeLockBtn.style.display = 'none';
                    }
                }
            }

            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('‚úì Screen wake lock acquired successfully');
                        
                        this.wakeLock.addEventListener('release', () => {
                            console.log('Screen wake lock released');
                            this.wakeLock = null;
                            if (this.isWakeLockEnabled) {
                                // Update button state if it was released externally
                                this.updateWakeLockButton();
                            }
                        });
                    }
                } catch (err) {
                    console.error('Wake lock request failed:', err.name, err.message);
                    if (err.name === 'NotAllowedError') {
                        this.showNotification('Wake lock denied - may need user interaction', 'error');
                    }
                }
            }

            releaseWakeLock() {
                if (this.wakeLock !== null) {
                    this.wakeLock.release()
                        .then(() => {
                            this.wakeLock = null;
                            console.log('Screen wake lock manually released');
                        })
                        .catch(err => {
                            console.error('Wake lock release failed:', err);
                        });
                }
            }

            async toggleWakeLock() {
                this.isWakeLockEnabled = !this.isWakeLockEnabled;
                
                if (this.isWakeLockEnabled) {
                    // Enable wake lock
                    await this.requestWakeLock();
                    this.showNotification('Screen wake lock enabled', 'success');
                } else {
                    // Disable wake lock
                    this.releaseWakeLock();
                    this.showNotification('Screen wake lock disabled', 'info');
                }
            }

            setSleepTimer(minutes) {
                // Clear existing timer
                if (this.sleepTimer) {
                    clearTimeout(this.sleepTimer);
                    this.sleepTimer = null;
                }
                
                if (minutes === 0) {
                    this.sleepTimerMinutes = 0;
                    this.sleepTimerEndTime = null;
                    this.showNotification('Sleep timer cancelled', 'info');
                    return;
                }
                
                this.sleepTimerMinutes = minutes;
                this.sleepTimerEndTime = Date.now() + (minutes * 60 * 1000);
                
                this.sleepTimer = setTimeout(() => {
                    // Pause playback
                    if (this.isPlaying) {
                        this.controller.pause();
                        this.isPlaying = false;
                        this.elements.playBtn.innerHTML = '<span class="btn-icon">‚ñ∂</span>';
                        this.elements.playBtn.classList.remove('playing');
                        this.saveProgress();
                    }
                    
                    this.sleepTimer = null;
                    this.sleepTimerMinutes = 0;
                    this.sleepTimerEndTime = null;
                    
                    this.showNotification('Sleep timer finished - playback paused', 'success');
                }, minutes * 60 * 1000);
                
                this.showNotification(`Sleep timer set for ${minutes} minute${minutes !== 1 ? 's' : ''}`, 'success');
            }

            getSleepTimerRemaining() {
                if (!this.sleepTimerEndTime) {
                    return null;
                }
                
                const remaining = Math.max(0, this.sleepTimerEndTime - Date.now());
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                
                return { minutes, seconds, total: remaining };
            }

            updateWakeLockButton() {
                // Update button state if needed
            }

            initController() {
                this.controller = new MediaOverlayController(
                    (segment) => {
                        this.currentSegmentIndex = this.segments.findIndex(s => s === segment);
                        this.clearHighlight();
                        this.highlightSegment(segment);
                        this.saveProgress();
                    },
                    () => this.handleNext()
                );
            }

            initUI() {
                this.elements = {
                    libraryView: document.getElementById('libraryView'),
                    readerView: document.getElementById('readerView'),
                    libraryGrid: document.getElementById('libraryGrid'),
                    emptyLibrary: document.getElementById('emptyLibrary'),
                    libraryStats: document.getElementById('libraryStats'),
                    libraryEpubInput: document.getElementById('libraryEpubInput'),
                    libraryMenuBtn: document.getElementById('libraryMenuBtn'),
                    libraryMenu: document.getElementById('libraryMenu'),
                    menuAddLocal: document.getElementById('menuAddLocal'),
                    menuAddCloud: document.getElementById('menuAddCloud'),
                    menuSync: document.getElementById('menuSync'),
                    backToLibraryBtn: document.getElementById('backToLibraryBtn'),
                    viewer: document.getElementById('viewer'),
                    readerArea: document.getElementById('readerArea'),
                    playBtn: document.getElementById('playBtn'),
                    prevBtn: document.getElementById('prevBtn'),
                    nextBtn: document.getElementById('nextBtn'),
                    chaptersBtn: document.getElementById('chaptersBtn'),
                    speedSlider: document.getElementById('speedSlider'),
                    speedDisplay: document.getElementById('speedDisplay'),
                    statusBar: document.getElementById('statusBar'),
                    bookTitle: document.getElementById('bookTitle'),
                    bookAuthor: document.getElementById('bookAuthor'),
                    bookChapter: document.getElementById('bookChapter'),
                    bookCover: document.getElementById('bookCover'),
                    bookCoverImage: document.getElementById('bookCoverImage'),
                    debugPanel: document.getElementById('debugPanel'),
                    debugContent: document.getElementById('debugContent'),
                    settingsBtn: document.getElementById('settingsBtn'),
                    fullscreenBtn: document.getElementById('fullscreenBtn'),
                    fullscreenIcon: document.getElementById('fullscreenIcon'),
                    pageNavigation: document.getElementById('pageNavigation'),
                    prevPageBtn: document.getElementById('prevPageBtn'),
                    nextPageBtn: document.getElementById('nextPageBtn'),
                    pageInfo: document.getElementById('pageInfo')
                };
                
                // Initialize font size from localStorage or default
                this.fontSize = parseInt(localStorage.getItem('fontSize')) || 18;
                this.fontFamily = localStorage.getItem('fontFamily') || 'sans';
                this.lineSpacing = localStorage.getItem('lineSpacing') || 'normal';
                this.textAlign = localStorage.getItem('textAlign') || 'left';
                this.pageMode = localStorage.getItem('pageMode') || 'paginated';
                this.applyFontSize();
                this.applyFontFamily();
                this.applyLineSpacing();
                this.applyTextAlignment();
                // Don't call applyPageMode here - no content loaded yet
                // Just set the UI state
                if (this.pageMode === 'paginated') {
                    this.elements.readerArea.classList.add('paginated');
                    this.elements.pageNavigation.classList.add('active');
                }
            }

            bindEvents() {
                // Hamburger menu toggle
                this.elements.libraryMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const menu = this.elements.libraryMenu;
                    menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
                });

                // Menu options
                this.elements.menuAddLocal.addEventListener('click', () => {
                    this.elements.libraryMenu.style.display = 'none';
                    this.elements.libraryEpubInput.click();
                });

                this.elements.menuAddCloud.addEventListener('click', () => {
                    this.elements.libraryMenu.style.display = 'none';
                    this.showCloudImportModal();
                });

                this.elements.menuSync.addEventListener('click', () => {
                    this.elements.libraryMenu.style.display = 'none';
                    this.handleSync();
                });

                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!this.elements.libraryMenuBtn.contains(e.target) && 
                        !this.elements.libraryMenu.contains(e.target)) {
                        this.elements.libraryMenu.style.display = 'none';
                    }
                });

                this.elements.libraryEpubInput.addEventListener('change', (e) => this.loadEPUBToLibrary(e));
                this.elements.backToLibraryBtn.addEventListener('click', () => this.showLibrary());
                this.elements.playBtn.addEventListener('click', () => this.togglePlay());
                this.elements.prevBtn.addEventListener('click', () => this.previousSegment());
                this.elements.nextBtn.addEventListener('click', () => this.nextSegment());
                this.elements.chaptersBtn.addEventListener('click', () => this.showAudioChapters());
                this.elements.settingsBtn.addEventListener('click', () => this.showSettingsModal());
                this.elements.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                
                // Page navigation buttons
                this.elements.prevPageBtn.addEventListener('click', () => this.previousPage());
                this.elements.nextPageBtn.addEventListener('click', () => this.nextPage());
                
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const speed = parseFloat(e.target.dataset.speed);
                        this.setSpeed(speed);
                        
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });
                
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                
                // Save progress before closing/refreshing
                window.addEventListener('beforeunload', () => {
                    if (this.currentBookId) {
                        this.saveProgress();
                        if (this.rendition && this.rendition.location) {
                            this.saveRegularEPUBProgress(this.rendition.location);
                        }
                        if (this.currentSpineIndex !== undefined && this.spineItems) {
                            this.saveDirectDisplayProgress();
                        }
                    }
                });
            }

            renderLibrary() {
                const books = this.libraryManager.getAllBooks();
                
                // Separate books by media overlay presence
                const booksWithMedia = books.filter(book => book.hasMediaOverlay === true);
                const booksWithoutMedia = books.filter(book => book.hasMediaOverlay !== true);
                
                this.elements.libraryStats.textContent = `${books.length} book${books.length !== 1 ? 's' : ''}`;
                
                if (books.length === 0) {
                    this.elements.emptyLibrary.style.display = 'block';
                    this.elements.libraryGrid.innerHTML = '';
                } else {
                    this.elements.emptyLibrary.style.display = 'none';
                    
                    let libraryHTML = '';
                    
                    // Add section for books with media overlays
                    if (booksWithMedia.length > 0) {
                        libraryHTML += `
                            <div style="grid-column: 1 / -1; margin-bottom: 1rem; margin-top: 1rem;">
                                <h2 style="color: var(--text-primary); font-size: 1.5rem; font-weight: 700; display: flex; align-items: center; gap: 0.5rem;">
                                    <span>üéß</span>
                                    <span>Audiobooks with Media Sync</span>
                                    <span style="font-size: 0.875rem; font-weight: 400; color: var(--text-secondary);">(${booksWithMedia.length})</span>
                                </h2>
                            </div>
                        `;
                        
                        libraryHTML += booksWithMedia.map(book => this.renderBookCard(book)).join('');
                    }
                    
                    // Add section for regular ebooks
                    if (booksWithoutMedia.length > 0) {
                        libraryHTML += `
                            <div style="grid-column: 1 / -1; margin-bottom: 1rem; margin-top: ${booksWithMedia.length > 0 ? '2rem' : '1rem'};">
                                <h2 style="color: var(--text-primary); font-size: 1.5rem; font-weight: 700; display: flex; align-items: center; gap: 0.5rem;">
                                    <span>üìö</span>
                                    <span>Regular Ebooks</span>
                                    <span style="font-size: 0.875rem; font-weight: 400; color: var(--text-secondary);">(${booksWithoutMedia.length})</span>
                                </h2>
                            </div>
                        `;
                        
                        libraryHTML += booksWithoutMedia.map(book => this.renderBookCard(book)).join('');
                    }
                    
                    this.elements.libraryGrid.innerHTML = libraryHTML;
                    
                    // Add event listeners to book cards
                    this.elements.libraryGrid.querySelectorAll('.book-card').forEach(card => {
                        card.addEventListener('click', (e) => {
                            // Don't open book if clicking on action button
                            if (e.target.closest('.book-card-action-btn')) {
                                const bookId = e.target.dataset.bookId;
                                this.removeBookFromLibrary(bookId);
                                return;
                            }
                            
                            const bookId = card.dataset.bookId;
                            this.openBookFromLibrary(bookId);
                        });
                    });
                }
            }
            
            renderBookCard(book) {
                return `
                    <div class="book-card" data-book-id="${book.id}">
                        <div class="book-card-cover">
                            ${book.coverImage ? 
                                `<img src="${book.coverImage}" alt="${book.title}" />` : 
                                'üìñ'
                            }
                            ${book.source === 'cloud' ? 
                                `<div class="cloud-icon-badge">‚òÅÔ∏è Cloud</div>` : 
                                ''
                            }
                            ${book.isCached ? 
                                `<div style="position: absolute; top: 0.5rem; left: 0.5rem; background: rgba(16, 185, 129, 0.9); color: white; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600;">Cached</div>` : 
                                book.source === 'cloud' ? 
                                    `<div style="position: absolute; top: 0.5rem; left: 0.5rem; background: rgba(0, 0, 0, 0.7); color: white; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600;">‚òÅÔ∏è Auto-download</div>` :
                                    `<div style="position: absolute; top: 0.5rem; left: 0.5rem; background: rgba(0, 0, 0, 0.7); color: white; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600;">üîÑ Re-upload needed</div>`
                            }
                            <div class="book-card-progress">
                                <div class="book-card-progress-bar" style="width: ${book.progress?.percentage || 0}%"></div>
                            </div>
                        </div>
                        <div class="book-card-info">
                            <div class="book-card-title">${book.title}</div>
                            <div class="book-card-author">${book.author}</div>
                            <div class="book-card-meta">
                                <span>${book.progress?.percentage || 0}%</span>
                                ${book.lastRead ? 
                                    `<span>${this.formatLastRead(book.lastRead)}</span>` : 
                                    `<span>Not started</span>`
                                }
                            </div>
                        </div>
                        <div class="book-card-actions">
                            <button class="book-card-action-btn" data-action="remove" data-book-id="${book.id}" title="Remove from library">
                                ‚úï
                            </button>
                        </div>
                    </div>
                `;
            }

            formatLastRead(dateString) {
                const date = new Date(dateString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);
                
                if (diffMins < 60) return 'Just now';
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                return date.toLocaleDateString();
            }

            formatFileSize(bytes) {
                if (!bytes) return '';
                const units = ['B', 'KB', 'MB', 'GB'];
                let size = bytes;
                let unitIndex = 0;
                
                while (size >= 1024 && unitIndex < units.length - 1) {
                    size /= 1024;
                    unitIndex++;
                }
                
                return `${size.toFixed(1)} ${units[unitIndex]}`;
            }

            showLibrary() {
                // Save current progress before leaving
                if (this.currentBookId) {
                    // Save progress for audiobooks
                    this.saveProgress();
                    
                    // Save progress for regular EPUBs with rendition
                    if (this.rendition && this.rendition.location) {
                        this.saveRegularEPUBProgress(this.rendition.location);
                    }
                    
                    // Save progress for direct display mode (file:// protocol)
                    if (this.currentSpineIndex !== undefined && this.spineItems) {
                        this.saveDirectDisplayProgress();
                    }
                }
                
                // Stop playback
                if (this.isPlaying) {
                    this.controller.pause();
                    this.isPlaying = false;
                }
                
                this.elements.libraryView.classList.add('active');
                this.elements.readerView.classList.remove('active');
                this.renderLibrary();
            }

            showReader() {
                this.elements.libraryView.classList.remove('active');
                this.elements.readerView.classList.add('active');
            }

            async detectMediaOverlay(book) {
                try {
                    await book.loaded.spine;
                    await book.loaded.manifest;
                    
                    const manifest = book.packaging.manifest;
                    
                    // First check: Look for SMIL files in the manifest (most reliable)
                    for (const [id, item] of Object.entries(manifest)) {
                        // Check media-type
                        if (item['media-type'] === 'application/smil+xml') {
                            console.log('‚úì Found SMIL by media-type:', id);
                            return true;
                        }
                        // Check mediaType (alternative property name)
                        if (item.mediaType === 'application/smil+xml') {
                            console.log('‚úì Found SMIL by mediaType:', id);
                            return true;
                        }
                        // Check href ending
                        if (item.href && item.href.endsWith('.smil')) {
                            console.log('‚úì Found SMIL by href:', item.href);
                            return true;
                        }
                    }
                    
                    // Second check: Look for media-overlay references in manifest items
                    for (const [id, item] of Object.entries(manifest)) {
                        // Try different property name variations
                        if (item['media-overlay'] || item.mediaOverlay || item['mediaOverlay']) {
                            console.log('‚úì Found media-overlay reference:', id);
                            return true;
                        }
                    }
                    
                    // Third check: Look for media-overlay references in spine items
                    for (const item of book.spine.items) {
                        const manifestItem = book.packaging.manifest[item.idref || item.id];
                        if (manifestItem) {
                            if (manifestItem['media-overlay'] || manifestItem.mediaOverlay || manifestItem['mediaOverlay']) {
                                console.log('‚úì Found media-overlay in spine item:', item.idref || item.id);
                                return true;
                            }
                        }
                    }
                    
                    console.log('‚úó No media overlays detected');
                    return false;
                } catch (e) {
                    console.log('Error detecting media overlay:', e);
                    return false;
                }
            }

            async loadEPUBToLibrary(e) {
                const file = e.target.files[0];
                if (!file) return;

                this.showNotification('Adding book to library...', 'info');

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const book = ePub(arrayBuffer);
                    await book.ready;
                    
                    // Extract metadata
                    await book.loaded.metadata;
                    const title = book.packaging.metadata.title || file.name;
                    const author = book.packaging.metadata.creator || 'Unknown Author';
                    
                    // Check for media overlays using comprehensive detection
                    const hasMediaOverlay = await this.detectMediaOverlay(book);
                    
                    // Store file metadata
                    const fileMetadata = {
                        name: file.name,
                        size: file.size,
                        lastModified: file.lastModified,
                        type: file.type
                    };
                    
                    // Generate unique ID
                    const bookId = this.generateBookId(title, author);
                    
                    // Try to extract and compress cover
                    let coverImage = null;
                    try {
                        await book.loaded.cover;
                        await book.loaded.resources;
                        
                        if (book.cover) {
                            const coverUrl = await book.cover;
                            if (coverUrl) {
                                const coverPath = book.resources.replacements[coverUrl] || coverUrl;
                                const archiveFiles = Object.keys(book.archive.zip.files);
                                
                                let actualCoverPath = null;
                                if (book.archive.zip.files[coverPath]) {
                                    actualCoverPath = coverPath;
                                } else {
                                    const coverFilename = coverPath.split('/').pop();
                                    actualCoverPath = archiveFiles.find(f => f.endsWith(coverFilename));
                                }
                                
                                if (actualCoverPath) {
                                    const coverFile = book.archive.zip.files[actualCoverPath];
                                    const coverData = await coverFile.async('arraybuffer');
                                    
                                    const extension = actualCoverPath.split('.').pop().toLowerCase();
                                    const mimeTypes = {
                                        'jpg': 'image/jpeg',
                                        'jpeg': 'image/jpeg',
                                        'png': 'image/png',
                                        'gif': 'image/gif',
                                        'webp': 'image/webp'
                                    };
                                    const mimeType = mimeTypes[extension] || 'image/jpeg';
                                    
                                    const blob = new Blob([coverData], { type: mimeType });
                                    
                                    // Compress the cover image to reduce storage
                                    try {
                                        coverImage = await this.compressImage(blob, 300, 400, 0.7);
                                    } catch (compressionError) {
                                        console.log('Image compression failed, using original:', compressionError);
                                        coverImage = await this.blobToBase64(blob);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Could not extract cover:', e);
                    }
                    
                    // Store book metadata only (no file data)
                    const bookData = {
                        id: bookId,
                        title: title,
                        author: author,
                        coverImage: coverImage,
                        filePath: file.name, // Store the file name
                        fileMetadata: fileMetadata, // Store additional file info
                        hasMediaOverlay: hasMediaOverlay, // Store media overlay status
                        addedDate: new Date().toISOString(),
                        lastRead: null,
                        progress: {
                            chapterIndex: 0,
                            segmentIndex: 0,
                            percentage: 0
                        }
                        // Note: NOT storing fileData here
                    };
                    
                    try {
                        this.libraryManager.addBook(bookData, false); // false = don't cache file data
                        this.renderLibrary();
                        
                        if (hasMediaOverlay) {
                            this.showNotification('Audiobook with media sync added!', 'success');
                        } else {
                            this.showNotification('Ebook added to library!', 'success');
                        }
                    } catch (storageError) {
                        if (storageError.name === 'QuotaExceededError') {
                            // Try without cover image
                            bookData.coverImage = null;
                            this.libraryManager.addBook(bookData, false);
                            this.renderLibrary();
                            this.showNotification('Book added (without cover due to storage limit)', 'info');
                        } else {
                            throw storageError;
                        }
                    }
                    
                    // Reset input
                    e.target.value = '';
                    
                } catch (error) {
                    console.error('Error adding book:', error);
                    this.showNotification('Error adding book to library', 'error');
                }
            }

            generateBookId(title, author) {
                const str = `${title}-${author}-${Date.now()}`;
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return 'book-' + Math.abs(hash).toString(36);
            }

            async blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            async compressImage(blob, maxWidth = 300, maxHeight = 400, quality = 0.7) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    img.onload = () => {
                        // Calculate new dimensions while maintaining aspect ratio
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > maxWidth || height > maxHeight) {
                            const ratio = Math.min(maxWidth / width, maxHeight / height);
                            width = width * ratio;
                            height = height * ratio;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // Draw and compress
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        canvas.toBlob((compressedBlob) => {
                            if (compressedBlob) {
                                this.blobToBase64(compressedBlob).then(resolve).catch(reject);
                            } else {
                                reject(new Error('Image compression failed'));
                            }
                        }, 'image/jpeg', quality);
                    };
                    
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });
            }

            removeBookFromLibrary(bookId) {
                if (confirm('Are you sure you want to remove this book from your library?')) {
                    this.libraryManager.removeBook(bookId);
                    this.renderLibrary();
                    this.showNotification('Book removed from library', 'info');
                }
            }

            async handleSync() {
                // Check if sync is configured
                if (!this.syncManager.isConfigured()) {
                    this.syncManager.showConfigDialog();
                    return;
                }

                // Show sync options modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 1rem;
                `;

                modal.innerHTML = `
                    <div style="background: #1e293b; border-radius: 1rem; padding: 2rem; max-width: 500px; width: 100%; color: #f8fafc;">
                        <h2 style="margin-bottom: 1.5rem; font-size: 1.5rem;">üîÑ Google Drive Sync</h2>
                        
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: #0f172a; border-radius: 0.5rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: 600; margin-bottom: 0.25rem;">Authentication</div>
                                    <div style="font-size: 0.875rem; color: ${this.syncManager.isTokenValid() ? '#10b981' : '#94a3b8'};">
                                        ${this.syncManager.isTokenValid() ? '‚úì Signed in (stays signed in)' : '‚óã Not signed in'}
                                    </div>
                                </div>
                                ${this.syncManager.isTokenValid() ? `
                                <button id="signOutBtn" style="background: #dc2626; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; cursor: pointer;">
                                    Sign Out
                                </button>
                                ` : ''}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: #0f172a; border-radius: 0.5rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: 600; margin-bottom: 0.25rem;">Auto-Sync</div>
                                    <div style="font-size: 0.875rem; color: #cbd5e1;">Sync every 5 minutes</div>
                                </div>
                                <label style="position: relative; display: inline-block; width: 50px; height: 26px;">
                                    <input type="checkbox" id="autoSyncToggle" ${this.syncManager.autoSyncEnabled ? 'checked' : ''} style="opacity: 0; width: 0; height: 0;">
                                    <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: ${this.syncManager.autoSyncEnabled ? '#10b981' : '#334155'}; border-radius: 26px; transition: 0.3s;" id="autoSyncSlider">
                                        <span style="position: absolute; content: ''; height: 18px; width: 18px; left: ${this.syncManager.autoSyncEnabled ? '26px' : '4px'}; bottom: 4px; background: white; border-radius: 50%; transition: 0.3s;"></span>
                                    </span>
                                </label>
                            </div>
                            ${this.syncManager.lastSyncTime ? `<div style="margin-top: 0.5rem; font-size: 0.75rem; color: #94a3b8;">Last sync: ${new Date(this.syncManager.lastSyncTime).toLocaleString()}</div>` : ''}
                        </div>
                        
                        <div style="display: flex; flex-direction: column; gap: 1rem;">
                            <button id="twoWaySync" style="background: #8b5cf6; color: white; border: none; padding: 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; font-size: 1rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                                üîÑ Force Full Sync
                            </button>
                            
                            <button id="uploadToGDrive" style="background: #10b981; color: white; border: none; padding: 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; font-size: 1rem;">
                                ‚¨ÜÔ∏è Upload to Google Drive
                            </button>
                            
                            <button id="downloadFromGDrive" style="background: #3b82f6; color: white; border: none; padding: 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; font-size: 1rem;">
                                ‚¨áÔ∏è Download from Google Drive
                            </button>
                            
                            <button id="configureSync" style="background: #64748b; color: white; border: none; padding: 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; font-size: 1rem;">
                                ‚öôÔ∏è Configure API Credentials
                            </button>
                            
                            <button id="resetSync" style="background: #f59e0b; color: white; border: none; padding: 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; font-size: 1rem;">
                                üîÑ Reset Sync (Fix Errors)
                            </button>
                            
                            <button id="cancelSync" style="background: #334155; color: white; border: none; padding: 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer; font-size: 1rem;">
                                Cancel
                            </button>
                        </div>
                        
                        <p style="margin-top: 1.5rem; font-size: 0.875rem; color: #cbd5e1; padding: 1rem; background: #0f172a; border-radius: 0.5rem;">
                            <strong>üí° Tip:</strong> Use Force Full Sync to merge all changes from Drive and upload the combined result. Auto-sync handles this automatically on startup!
                        </p>
                    </div>
                `;

                document.body.appendChild(modal);

                // Sign out button handler
                const signOutBtn = modal.querySelector('#signOutBtn');
                if (signOutBtn) {
                    signOutBtn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to sign out of Google Drive?')) {
                            this.syncManager.clearSavedAuth();
                            modal.remove();
                            this.showNotification('Signed out of Google Drive', 'info');
                        }
                    });
                }

                // Force Full Sync handler
                modal.querySelector('#twoWaySync').addEventListener('click', async () => {
                    modal.remove();
                    this.showNotification('üîÑ Starting force full sync...', 'info');
                    
                    try {
                        // First, download remote data
                        const downloadResult = await this.syncManager.syncFromGoogleDrive();
                        
                        if (downloadResult.success) {
                            // Merge with local
                            const localBooks = this.libraryManager.getAllBooks();
                            const remoteBooks = downloadResult.data || [];
                            const remoteDeletedBooks = downloadResult.deletedBooks || [];
                            
                            const mergedBooks = this.syncManager.mergeLibraries(
                                localBooks, 
                                remoteBooks, 
                                remoteDeletedBooks
                            );
                            
                            // Update local library
                            this.libraryManager.books = [];
                            mergedBooks.forEach(book => {
                                this.libraryManager.addBook(book, false);
                            });
                            
                            // Now upload the merged result
                            const uploadResult = await this.syncManager.syncToGoogleDrive(mergedBooks);
                            
                            if (uploadResult.success) {
                                this.renderLibrary();
                                this.showNotification('‚úì Force full sync complete! All devices now in sync.', 'success');
                            } else {
                                this.showNotification('‚ö†Ô∏è Merge successful but upload failed: ' + uploadResult.error, 'error');
                            }
                        } else {
                            // No remote data yet, just upload
                            const books = this.libraryManager.getAllBooks();
                            const uploadResult = await this.syncManager.syncToGoogleDrive(books);
                            
                            if (uploadResult.success) {
                                this.showNotification('‚úì Uploaded to Google Drive (first sync)', 'success');
                            } else {
                                this.showNotification('Sync failed: ' + uploadResult.error, 'error');
                            }
                        }
                    } catch (error) {
                        console.error('Force full sync error:', error);
                        this.showNotification('Sync failed: ' + error.message, 'error');
                    }
                });

                modal.querySelector('#uploadToGDrive').addEventListener('click', async () => {
                    modal.remove();
                    this.showNotification('‚è≥ Uploading to Google Drive...', 'info');
                    
                    try {
                        const books = this.libraryManager.getAllBooks();
                        const result = await this.syncManager.syncToGoogleDrive(books);
                        
                        if (result.success) {
                            this.showNotification('‚úì Uploaded to Google Drive!', 'success');
                        } else {
                            this.showNotification('Upload failed: ' + result.error, 'error');
                        }
                    } catch (error) {
                        console.error('Upload error:', error);
                        this.showNotification('Upload failed: ' + error.message, 'error');
                    }
                });

                modal.querySelector('#downloadFromGDrive').addEventListener('click', async () => {
                    modal.remove();
                    this.showNotification('‚è≥ Syncing from Google Drive...', 'info');
                    
                    const result = await this.syncManager.syncFromGoogleDrive();
                    
                    if (result.success) {
                        // Smart merge with local library
                        const localBooks = this.libraryManager.getAllBooks();
                        const remoteBooks = result.data || [];
                        const remoteDeletedBooks = result.deletedBooks || [];
                        
                        // Perform smart merge
                        const mergedBooks = this.syncManager.mergeLibraries(
                            localBooks, 
                            remoteBooks, 
                            remoteDeletedBooks
                        );
                        
                        // Show what will happen
                        const added = mergedBooks.filter(mb => !localBooks.find(lb => lb.id === mb.id)).length;
                        const updated = mergedBooks.filter(mb => {
                            const local = localBooks.find(lb => lb.id === mb.id);
                            return local && (local.lastRead !== mb.lastRead || 
                                   JSON.stringify(local.progress) !== JSON.stringify(mb.progress));
                        }).length;
                        const removed = remoteDeletedBooks.length;
                        
                        let message = `Sync from ${new Date(result.lastSync).toLocaleString()}\n\n`;
                        if (added > 0) message += `‚Ä¢ ${added} book(s) will be added\n`;
                        if (updated > 0) message += `‚Ä¢ ${updated} book(s) will be updated\n`;
                        if (removed > 0) message += `‚Ä¢ ${removed} book(s) will be removed\n`;
                        if (added === 0 && updated === 0 && removed === 0) {
                            message += `‚Ä¢ Everything is already in sync!\n`;
                        }
                        message += '\nContinue?';
                        
                        if (window.confirm(message)) {
                            // Clear local library and add merged books
                            this.libraryManager.books = [];
                            mergedBooks.forEach(book => {
                                this.libraryManager.addBook(book, false);
                            });
                            
                            this.renderLibrary();
                            this.showNotification(`‚úì Library synced! ${added} added, ${updated} updated, ${removed} removed`, 'success');
                        }
                    } else {
                        // Show appropriate error message
                        if (result.errorCode === 404) {
                            this.showNotification('‚ö†Ô∏è Sync file not found. Click "Reset Sync" to fix this, then use "Upload" to create a new sync file.', 'error');
                        } else if (result.needsAuth) {
                            this.showNotification('üîê ' + result.error, 'error');
                        } else if (result.needsFirstSync) {
                            this.showNotification('üì§ No sync file yet. Use "Upload" or "Two-Way Sync" to create one.', 'info');
                        } else {
                            this.showNotification('Sync failed: ' + result.error, 'error');
                        }
                    }
                });

                // Auto-sync toggle
                const autoSyncToggle = modal.querySelector('#autoSyncToggle');
                const autoSyncSlider = modal.querySelector('#autoSyncSlider');
                autoSyncToggle.addEventListener('change', (e) => {
                    const enabled = e.target.checked;
                    
                    if (enabled) {
                        this.syncManager.enableAutoSync();
                        this.syncManager.startAutoSync(this.libraryManager);
                        autoSyncSlider.style.background = '#10b981';
                        autoSyncSlider.querySelector('span').style.left = '26px';
                        this.showNotification('Auto-sync enabled (every 5 minutes)', 'success');
                    } else {
                        this.syncManager.disableAutoSync();
                        autoSyncSlider.style.background = '#334155';
                        autoSyncSlider.querySelector('span').style.left = '4px';
                        this.showNotification('Auto-sync disabled', 'info');
                    }
                });

                modal.querySelector('#configureSync').addEventListener('click', () => {
                    modal.remove();
                    this.syncManager.showConfigDialog();
                });

                modal.querySelector('#resetSync').addEventListener('click', () => {
                    if (confirm('This will reset your Google Drive sync connection.\n\nYour local library will NOT be deleted, but you\'ll need to sync again.\n\nContinue?')) {
                        // Clear sync data
                        localStorage.removeItem('gdrive_sync_file_id');
                        localStorage.removeItem('deleted_books');
                        localStorage.removeItem('last_sync_time');
                        this.syncManager.fileId = null;
                        
                        modal.remove();
                        this.showNotification('‚úì Sync reset! Use "Upload" or "Two-Way Sync" to create a fresh sync file.', 'success');
                    }
                });

                modal.querySelector('#cancelSync').addEventListener('click', () => {
                    modal.remove();
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
            }

            showCloudImportModal() {
                const modal = document.createElement('div');
                modal.className = 'cloud-modal';
                
                modal.innerHTML = `
                    <div class="cloud-modal-content">
                        <h2 class="cloud-modal-title">
                            <span>‚òÅÔ∏è</span>
                            <span>Import from Cloud</span>
                        </h2>
                        <p class="cloud-modal-description">
                            Enter a direct download link to your EPUB file from Dropbox, Google Drive, or any cloud storage.
                        </p>
                        
                        <div class="cloud-help">
                            <div class="cloud-help-title">How to get a direct link:</div>
                            <strong>Dropbox:</strong> Share link and change ?dl=0 to ?dl=1<br>
                            <strong>Google Drive:</strong> Use: https://drive.google.com/uc?export=download&id=FILE_ID<br>
                            <small style="display: block; margin-top: 0.5rem; opacity: 0.8;">
                                ‚ÑπÔ∏è Uses CORS proxy (corsproxy.io) to bypass browser restrictions
                            </small>
                        </div>
                        
                        <input 
                            type="url" 
                            class="cloud-modal-input" 
                            id="cloudUrlInput" 
                            placeholder="https://example.com/book.epub"
                            autocomplete="off"
                        />
                        
                        <div class="cloud-modal-buttons">
                            <button class="cloud-modal-btn cloud-modal-btn-secondary" id="cloudCancelBtn">
                                Cancel
                            </button>
                            <button class="cloud-modal-btn cloud-modal-btn-primary" id="cloudImportBtn">
                                Import Book
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const input = modal.querySelector('#cloudUrlInput');
                const cancelBtn = modal.querySelector('#cloudCancelBtn');
                const importBtn = modal.querySelector('#cloudImportBtn');
                
                // Focus input
                setTimeout(() => input.focus(), 100);
                
                // Handle cancel
                cancelBtn.addEventListener('click', () => modal.remove());
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
                
                // Handle import
                importBtn.addEventListener('click', async () => {
                    const url = input.value.trim();
                    if (!url) {
                        this.showNotification('Please enter a URL', 'error');
                        return;
                    }
                    
                    // Validate URL
                    try {
                        new URL(url);
                    } catch (e) {
                        this.showNotification('Please enter a valid URL', 'error');
                        return;
                    }
                    
                    importBtn.disabled = true;
                    importBtn.textContent = 'Importing...';
                    
                    modal.remove();
                    await this.downloadFromCloud(url);
                });
                
                // Handle enter key
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        importBtn.click();
                    }
                });
                
                // Escape to close
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
            }

            async downloadFromCloud(url) {
                this.showNotification('Downloading book from cloud...', 'info');
                
                try {
                    // Use CORS proxy for cloud downloads
                    const corsProxy = 'https://corsproxy.io/?';
                    const proxiedUrl = corsProxy + encodeURIComponent(url);
                    
                    const response = await fetch(proxiedUrl);
                    
                    if (!response.ok) {
                        throw new Error(`Download failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const arrayBuffer = await response.arrayBuffer();
                    
                    if (arrayBuffer.byteLength === 0) {
                        throw new Error('Downloaded file is empty');
                    }
                    
                    // Try to parse as EPUB
                    const book = ePub(arrayBuffer);
                    await book.ready;
                    
                    // Extract metadata
                    await book.loaded.metadata;
                    const title = book.packaging.metadata.title || 'Unknown Title';
                    const author = book.packaging.metadata.creator || 'Unknown Author';
                    
                    // Check for media overlays using comprehensive detection
                    const hasMediaOverlay = await this.detectMediaOverlay(book);
                    
                    // Generate unique ID
                    const bookId = this.generateBookId(title, author);
                    
                    // Try to extract and compress cover
                    let coverImage = null;
                    try {
                        await book.loaded.cover;
                        await book.loaded.resources;
                        
                        if (book.cover) {
                            const coverUrl = await book.cover;
                            if (coverUrl) {
                                const coverPath = book.resources.replacements[coverUrl] || coverUrl;
                                const archiveFiles = Object.keys(book.archive.zip.files);
                                
                                let actualCoverPath = null;
                                if (book.archive.zip.files[coverPath]) {
                                    actualCoverPath = coverPath;
                                } else {
                                    const coverFilename = coverPath.split('/').pop();
                                    actualCoverPath = archiveFiles.find(f => f.endsWith(coverFilename));
                                }
                                
                                if (actualCoverPath) {
                                    const coverFile = book.archive.zip.files[actualCoverPath];
                                    const coverData = await coverFile.async('arraybuffer');
                                    
                                    const extension = actualCoverPath.split('.').pop().toLowerCase();
                                    const mimeTypes = {
                                        'jpg': 'image/jpeg',
                                        'jpeg': 'image/jpeg',
                                        'png': 'image/png',
                                        'gif': 'image/gif',
                                        'webp': 'image/webp'
                                    };
                                    const mimeType = mimeTypes[extension] || 'image/jpeg';
                                    
                                    const blob = new Blob([coverData], { type: mimeType });
                                    
                                    // Compress the cover image
                                    try {
                                        coverImage = await this.compressImage(blob, 300, 400, 0.7);
                                    } catch (compressionError) {
                                        console.log('Image compression failed, using original:', compressionError);
                                        coverImage = await this.blobToBase64(blob);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Could not extract cover:', e);
                    }
                    
                    // Store book metadata with cloud info
                    const bookData = {
                        id: bookId,
                        title: title,
                        author: author,
                        coverImage: coverImage,
                        filePath: url, // Store the cloud URL as the file path
                        hasMediaOverlay: hasMediaOverlay, // Store media overlay status
                        addedDate: new Date().toISOString(),
                        lastRead: null,
                        progress: {
                            chapterIndex: 0,
                            segmentIndex: 0,
                            percentage: 0
                        },
                        source: 'cloud',
                        cloudUrl: url
                    };
                    
                    try {
                        this.libraryManager.addBook(bookData, false);
                        this.renderLibrary();
                        
                        if (hasMediaOverlay) {
                            this.showNotification('Audiobook with media sync imported!', 'success');
                        } else {
                            this.showNotification('Ebook imported from cloud successfully!', 'success');
                        }
                    } catch (storageError) {
                        if (storageError.name === 'QuotaExceededError') {
                            // Try without cover image
                            bookData.coverImage = null;
                            this.libraryManager.addBook(bookData, false);
                            this.renderLibrary();
                            this.showNotification('Book imported (without cover due to storage limit)', 'info');
                        } else {
                            throw storageError;
                        }
                    }
                    
                } catch (error) {
                    console.error('Error downloading from cloud:', error);
                    this.showNotification('Failed to import book: ' + error.message, 'error');
                }
            }

            showBookLoading(bookId, message = 'Loading...') {
                const bookCard = document.querySelector(`[data-book-id="${bookId}"]`);
                if (!bookCard) return;
                
                const cover = bookCard.querySelector('.book-card-cover');
                if (!cover) return;
                
                // Remove existing overlay if any
                const existingOverlay = cover.querySelector('.book-loading-overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                // Create loading overlay
                const overlay = document.createElement('div');
                overlay.className = 'book-loading-overlay';
                overlay.innerHTML = `
                    <div class="book-loading-spinner"></div>
                    <div class="book-loading-text">${message}</div>
                `;
                
                cover.appendChild(overlay);
            }

            hideBookLoading(bookId) {
                const bookCard = document.querySelector(`[data-book-id="${bookId}"]`);
                if (!bookCard) return;
                
                const overlay = bookCard.querySelector('.book-loading-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }

            async openBookFromLibrary(bookId) {
                const bookData = this.libraryManager.getBook(bookId);
                if (!bookData) {
                    this.showNotification('Book not found', 'error');
                    return;
                }

                // Check if book file data is cached
                if (!bookData.fileData) {
                    // Check if it's a cloud book
                    if (bookData.source === 'cloud' && bookData.cloudUrl) {
                        // Show loading spinner
                        this.showBookLoading(bookId, 'Downloading...');
                        
                        // Automatically download from cloud
                        this.showNotification('Downloading book from cloud...', 'info');
                        
                        try {
                            // Use CORS proxy
                            const corsProxy = 'https://corsproxy.io/?';
                            const proxiedUrl = corsProxy + encodeURIComponent(bookData.cloudUrl);
                            
                            const response = await fetch(proxiedUrl);
                            
                            if (!response.ok) {
                                throw new Error(`Download failed: ${response.status}`);
                            }
                            
                            const arrayBuffer = await response.arrayBuffer();
                            
                            // Hide loading spinner
                            this.hideBookLoading(bookId);
                            
                            // Cache this book's file data
                            this.libraryManager.cacheBookData(bookId, arrayBuffer);
                            
                            // Now open the book
                            await this.openBookWithData(bookId, arrayBuffer);
                            
                        } catch (error) {
                            // Hide loading spinner
                            this.hideBookLoading(bookId);
                            
                            console.error('Error downloading from cloud:', error);
                            this.showNotification('Failed to download book from cloud: ' + error.message, 'error');
                        }
                        
                        return;
                    }
                    
                    // Local book needs to be re-uploaded
                    this.showNotification('Please re-upload this book to continue reading', 'info');
                    
                    // Show file picker for this specific book
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.epub';
                    input.onchange = async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        // Show loading spinner
                        this.showBookLoading(bookId, 'Loading...');
                        
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            
                            // Hide loading spinner
                            this.hideBookLoading(bookId);
                            
                            // Cache this book's file data (will remove from other books)
                            this.libraryManager.cacheBookData(bookId, arrayBuffer);
                            
                            // Now open the book
                            await this.openBookWithData(bookId, arrayBuffer);
                        } catch (error) {
                            // Hide loading spinner
                            this.hideBookLoading(bookId);
                            
                            console.error('Error loading book:', error);
                            this.showNotification('Error loading book file', 'error');
                        }
                    };
                    input.click();
                    return;
                }

                // Book is cached, show loading while opening
                this.showBookLoading(bookId, 'Opening...');
                
                try {
                    await this.openBookWithData(bookId, bookData.fileData);
                    // Loading spinner will be hidden when library view is hidden
                } catch (error) {
                    this.hideBookLoading(bookId);
                    throw error;
                }
            }

            async openBookWithData(bookId, fileData) {
                const bookData = this.libraryManager.getBook(bookId);
                if (!bookData) {
                    this.showNotification('Book not found', 'error');
                    return;
                }

                this.currentBookId = bookId;
                this.showReader();
                this.showNotification('Opening book...', 'info');

                try {
                    this.book = ePub(fileData);
                    await this.book.ready;
                    
                    this.bookMetadata = {
                        title: bookData.title,
                        author: bookData.author,
                        coverImage: bookData.coverImage
                    };
                    
                    this.elements.bookTitle.textContent = bookData.title;
                    this.elements.bookAuthor.textContent = bookData.author;
                    
                    if (bookData.coverImage) {
                        this.elements.bookCoverImage.src = bookData.coverImage;
                        this.elements.bookCover.style.display = 'block';
                    }
                    
                    await this.checkMediaOverlays();
                    
                    // Resume from saved position
                    if (bookData.progress && bookData.progress.chapterIndex !== undefined && bookData.progress.percentage > 0) {
                        const chapterIndex = bookData.progress.chapterIndex;
                        const savedSegmentIndex = bookData.progress.segmentIndex || 0;
                        
                        if (this.overlayChapters[chapterIndex]) {
                            await this.loadChapterOverlay(this.overlayChapters[chapterIndex]);
                            
                            // Restore the saved segment position after chapter loads
                            this.currentSegmentIndex = savedSegmentIndex;
                            this.controller.currentSegmentIndex = savedSegmentIndex;
                            
                            // Highlight and scroll to the saved segment
                            if (this.segments[savedSegmentIndex]) {
                                this.highlightSegment(this.segments[savedSegmentIndex]);
                            }
                            
                            this.showNotification(`Resumed at ${bookData.progress.percentage}%`, 'success');
                        }
                    } else {
                        // Start from beginning if no saved progress
                        if (this.overlayChapters.length > 0) {
                            await this.loadChapterOverlay(this.overlayChapters[0]);
                        }
                    }
                    
                } catch (error) {
                    console.error('Error opening book:', error);
                    this.showNotification('Error opening book: ' + error.message, 'error');
                }
            }

            saveProgress() {
                if (!this.currentBookId) return;
                
                // For audiobooks with media overlay
                if (this.currentChapter && this.overlayChapters.length > 0) {
                    const chapterIndex = this.overlayChapters.findIndex(ch => ch.href === this.currentChapter.href);
                    const totalChapters = this.overlayChapters.length;
                    const totalSegments = this.segments.length;
                    
                    // Calculate percentage
                    let percentage = 0;
                    if (totalChapters > 0) {
                        const chapterProgress = chapterIndex / totalChapters;
                        const segmentProgress = totalSegments > 0 ? this.currentSegmentIndex / totalSegments : 0;
                        percentage = Math.round((chapterProgress + (segmentProgress / totalChapters)) * 100);
                    }
                    
                    const progress = {
                        chapterIndex: chapterIndex,
                        segmentIndex: this.currentSegmentIndex,
                        percentage: Math.min(percentage, 100)
                    };
                    
                    this.libraryManager.updateProgress(this.currentBookId, progress);
                }
            }
            
            saveRegularEPUBProgress(location) {
                if (!this.currentBookId || !location) return;
                
                try {
                    // Save CFI (Canonical Fragment Identifier) for exact position
                    const cfi = location.start?.cfi || location.cfi;
                    
                    // Calculate percentage - handle different epub.js modes
                    let percentage = 0;
                    
                    // Try to get percentage from location object
                    if (location.start?.percentage !== undefined) {
                        percentage = Math.round(location.start.percentage * 100);
                    } else if (location.start?.location !== undefined && location.end?.location !== undefined) {
                        // Calculate from location numbers
                        const current = location.start.location;
                        const total = this.book?.locations?.total || 100;
                        percentage = Math.round((current / total) * 100);
                    } else if (this.rendition?.location) {
                        // Fallback to rendition's current location
                        const currentLoc = this.rendition.location.start;
                        if (currentLoc?.percentage !== undefined) {
                            percentage = Math.round(currentLoc.percentage * 100);
                        }
                    }
                    
                    const progress = {
                        cfi: cfi,
                        percentage: Math.min(percentage, 100),
                        lastRead: new Date().toISOString()
                    };
                    
                    this.libraryManager.updateProgress(this.currentBookId, progress);
                    
                    console.log('Progress saved for regular EPUB:', percentage + '%', cfi);
                } catch (error) {
                    console.error('Error saving regular EPUB progress:', error);
                }
            }
            
            saveDirectDisplayProgress() {
                if (!this.currentBookId || this.currentSpineIndex === undefined || !this.spineItems) return;
                
                try {
                    // Calculate percentage based on chapter position
                    const totalChapters = this.spineItems.length;
                    const percentage = Math.round((this.currentSpineIndex / totalChapters) * 100);
                    
                    const progress = {
                        chapterIndex: this.currentSpineIndex,
                        percentage: Math.min(percentage, 100),
                        lastRead: new Date().toISOString()
                    };
                    
                    this.libraryManager.updateProgress(this.currentBookId, progress);
                    
                    console.log('Progress saved for direct display:', percentage + '% (chapter', this.currentSpineIndex + 1, 'of', totalChapters + ')');
                } catch (error) {
                    console.error('Error saving direct display progress:', error);
                }
            }

            showSettingsModal() {
                const modal = document.createElement('div');
                modal.className = 'settings-modal';
                
                // Get current sleep timer status
                const timerStatus = this.getSleepTimerRemaining();
                let timerStatusText = 'No timer set';
                if (timerStatus && timerStatus.total > 0) {
                    timerStatusText = `‚è∞ ${timerStatus.minutes}:${timerStatus.seconds.toString().padStart(2, '0')} remaining`;
                }
                
                modal.innerHTML = `
                    <div class="settings-content" style="max-width: 500px;">
                        <div class="settings-header">
                            <h2 class="settings-title">
                                <span>‚öôÔ∏è</span>
                                <span>Settings</span>
                            </h2>
                            <button class="settings-close" id="settingsCloseBtn">‚úï</button>
                        </div>
                        
                        <div class="settings-section">
                            <label class="settings-label">
                                Font Size
                                <span class="settings-value" id="fontSizeValue">${this.fontSize}px</span>
                            </label>
                            <input 
                                type="range" 
                                class="settings-slider" 
                                id="fontSizeSlider"
                                min="12"
                                max="32"
                                value="${this.fontSize}"
                            />
                        </div>
                        
                        <div class="settings-section">
                            <label class="settings-label">
                                Font Family
                            </label>
                            <div class="font-selector">
                                <button class="font-option serif ${this.fontFamily === 'serif' ? 'active' : ''}" data-font="serif">Georgia</button>
                                <button class="font-option palatino ${this.fontFamily === 'palatino' ? 'active' : ''}" data-font="palatino">Palatino</button>
                                <button class="font-option garamond ${this.fontFamily === 'garamond' ? 'active' : ''}" data-font="garamond">Garamond</button>
                                <button class="font-option bookerly ${this.fontFamily === 'bookerly' ? 'active' : ''}" data-font="bookerly">Bookerly</button>
                                <button class="font-option sans ${this.fontFamily === 'sans' ? 'active' : ''}" data-font="sans">System</button>
                                <button class="font-option opensans ${this.fontFamily === 'opensans' ? 'active' : ''}" data-font="opensans">Open Sans</button>
                                <button class="font-option roboto ${this.fontFamily === 'roboto' ? 'active' : ''}" data-font="roboto">Roboto</button>
                                <button class="font-option arial ${this.fontFamily === 'arial' ? 'active' : ''}" data-font="arial">Arial</button>
                                <button class="font-option verdana ${this.fontFamily === 'verdana' ? 'active' : ''}" data-font="verdana">Verdana</button>
                                <button class="font-option mono ${this.fontFamily === 'mono' ? 'active' : ''}" data-font="mono">Mono</button>
                                <button class="font-option dyslexic ${this.fontFamily === 'dyslexic' ? 'active' : ''}" data-font="dyslexic">Dyslexic</button>
                                <button class="font-option atkinson ${this.fontFamily === 'atkinson' ? 'active' : ''}" data-font="atkinson">Atkinson</button>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <label class="settings-label">
                                Text Alignment
                            </label>
                            <div class="alignment-selector">
                                <button class="alignment-option ${this.textAlign === 'left' ? 'active' : ''}" data-align="left">Left Aligned</button>
                                <button class="alignment-option ${this.textAlign === 'justify' ? 'active' : ''}" data-align="justify">Justified</button>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <label class="settings-label">
                                üìÑ Reading Mode
                            </label>
                            <div class="page-mode-selector">
                                <button class="page-mode-option ${this.pageMode === 'scroll' ? 'active' : ''}" data-mode="scroll">Scroll</button>
                                <button class="page-mode-option ${this.pageMode === 'paginated' ? 'active' : ''}" data-mode="paginated">Page Flip</button>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <label class="settings-label">
                                Line Spacing
                            </label>
                            <div class="spacing-selector">
                                <button class="spacing-option ${this.lineSpacing === 'compact' ? 'active' : ''}" data-spacing="compact">Compact</button>
                                <button class="spacing-option ${this.lineSpacing === 'normal' ? 'active' : ''}" data-spacing="normal">Normal</button>
                                <button class="spacing-option ${this.lineSpacing === 'relaxed' ? 'active' : ''}" data-spacing="relaxed">Relaxed</button>
                                <button class="spacing-option ${this.lineSpacing === 'loose' ? 'active' : ''}" data-spacing="loose">Loose</button>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <label class="settings-label">
                                ‚è∞ Sleep Timer
                            </label>
                            <div class="sleep-timer-controls">
                                <button class="sleep-timer-btn" data-minutes="15">15 min</button>
                                <button class="sleep-timer-btn" data-minutes="30">30 min</button>
                                <button class="sleep-timer-btn" data-minutes="45">45 min</button>
                                <button class="sleep-timer-btn" data-minutes="60">60 min</button>
                            </div>
                            <div class="sleep-timer-status ${timerStatus ? 'active' : ''}" id="sleepTimerStatus">
                                ${timerStatusText}
                            </div>
                            ${timerStatus ? '<button class="sleep-timer-btn" id="cancelSleepTimer" style="margin-top: 0.5rem; width: 100%;">Cancel Timer</button>' : ''}
                        </div>
                        
                        <div class="settings-section">
                            <div class="settings-toggle" id="darkModeToggle">
                                <span class="settings-toggle-label">
                                    <span>üåô</span>
                                    <span>Dark Mode</span>
                                </span>
                                <div class="toggle-switch ${this.isDarkMode ? 'active' : ''}" id="darkModeSwitch"></div>
                            </div>
                            
                            <div class="settings-toggle" id="wakeLockToggle">
                                <span class="settings-toggle-label">
                                    <span>‚òÄÔ∏è</span>
                                    <span>Keep Screen Awake</span>
                                </span>
                                <div class="toggle-switch ${this.isWakeLockEnabled ? 'active' : ''}" id="wakeLockSwitch"></div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Font size slider
                const fontSizeSlider = modal.querySelector('#fontSizeSlider');
                const fontSizeValue = modal.querySelector('#fontSizeValue');
                
                fontSizeSlider.addEventListener('input', (e) => {
                    this.fontSize = parseInt(e.target.value);
                    fontSizeValue.textContent = this.fontSize + 'px';
                    this.applyFontSize();
                    localStorage.setItem('fontSize', this.fontSize);
                });
                
                // Font family selector
                const fontOptions = modal.querySelectorAll('.font-option');
                fontOptions.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const font = btn.dataset.font;
                        this.fontFamily = font;
                        this.applyFontFamily();
                        localStorage.setItem('fontFamily', font);
                        
                        // Update active state
                        fontOptions.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });
                
                // Line spacing selector
                const spacingOptions = modal.querySelectorAll('.spacing-option');
                spacingOptions.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const spacing = btn.dataset.spacing;
                        this.lineSpacing = spacing;
                        this.applyLineSpacing();
                        localStorage.setItem('lineSpacing', spacing);
                        
                        // Update active state
                        spacingOptions.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });
                
                // Text alignment selector
                const alignmentOptions = modal.querySelectorAll('.alignment-option');
                alignmentOptions.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const align = btn.dataset.align;
                        this.textAlign = align;
                        this.applyTextAlignment();
                        localStorage.setItem('textAlign', align);
                        
                        // Update active state
                        alignmentOptions.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });
                
                // Page mode selector
                const pageModeOptions = modal.querySelectorAll('.page-mode-option');
                pageModeOptions.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const mode = btn.dataset.mode;
                        this.pageMode = mode;
                        localStorage.setItem('pageMode', mode);
                        
                        // Update active state
                        pageModeOptions.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // Update container overflow immediately if using direct display
                        if (this.readerContainer) {
                            const containerOverflow = mode === 'paginated' ? 'hidden' : 'auto';
                            this.readerContainer.style.overflowY = containerOverflow;
                        }
                        
                        // Apply the mode and reload current chapter
                        this.applyPageMode();
                        
                        // Reload current chapter if using direct display
                        if (this.readerContainer && this.currentSpineIndex !== undefined) {
                            this.displayChapterDirect(this.currentSpineIndex, false);
                        }
                    });
                });
                
                // Sleep timer buttons
                const sleepTimerBtns = modal.querySelectorAll('.sleep-timer-btn[data-minutes]');
                sleepTimerBtns.forEach(btn => {
                    const minutes = parseInt(btn.dataset.minutes);
                    if (this.sleepTimerMinutes === minutes) {
                        btn.classList.add('active');
                    }
                    
                    btn.addEventListener('click', () => {
                        this.setSleepTimer(minutes);
                        
                        // Update UI
                        sleepTimerBtns.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const statusEl = modal.querySelector('#sleepTimerStatus');
                        statusEl.textContent = `‚è∞ Timer set for ${minutes} minutes`;
                        statusEl.classList.add('active');
                        
                        // Add cancel button if not present
                        if (!modal.querySelector('#cancelSleepTimer')) {
                            const cancelBtn = document.createElement('button');
                            cancelBtn.className = 'sleep-timer-btn';
                            cancelBtn.id = 'cancelSleepTimer';
                            cancelBtn.textContent = 'Cancel Timer';
                            cancelBtn.style.marginTop = '0.5rem';
                            cancelBtn.style.width = '100%';
                            cancelBtn.addEventListener('click', () => {
                                this.setSleepTimer(0);
                                cancelBtn.remove();
                                sleepTimerBtns.forEach(b => b.classList.remove('active'));
                                statusEl.textContent = 'No timer set';
                                statusEl.classList.remove('active');
                            });
                            statusEl.parentElement.appendChild(cancelBtn);
                        }
                    });
                });
                
                // Cancel sleep timer button
                const cancelBtn = modal.querySelector('#cancelSleepTimer');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        this.setSleepTimer(0);
                        cancelBtn.remove();
                        sleepTimerBtns.forEach(b => b.classList.remove('active'));
                        const statusEl = modal.querySelector('#sleepTimerStatus');
                        statusEl.textContent = 'No timer set';
                        statusEl.classList.remove('active');
                    });
                }
                
                // Update timer display every second if timer is active
                let timerInterval = null;
                if (timerStatus) {
                    timerInterval = setInterval(() => {
                        const remaining = this.getSleepTimerRemaining();
                        const statusEl = modal.querySelector('#sleepTimerStatus');
                        if (remaining && remaining.total > 0) {
                            statusEl.textContent = `‚è∞ ${remaining.minutes}:${remaining.seconds.toString().padStart(2, '0')} remaining`;
                        } else {
                            statusEl.textContent = 'No timer set';
                            statusEl.classList.remove('active');
                            if (timerInterval) {
                                clearInterval(timerInterval);
                            }
                        }
                    }, 1000);
                }
                
                // Dark mode toggle
                const darkModeToggle = modal.querySelector('#darkModeToggle');
                darkModeToggle.addEventListener('click', () => {
                    this.toggleDarkMode();
                    const darkModeSwitch = modal.querySelector('#darkModeSwitch');
                    darkModeSwitch.classList.toggle('active');
                });
                
                // Wake lock toggle
                const wakeLockToggle = modal.querySelector('#wakeLockToggle');
                wakeLockToggle.addEventListener('click', async () => {
                    await this.toggleWakeLock();
                    const wakeLockSwitch = modal.querySelector('#wakeLockSwitch');
                    wakeLockSwitch.classList.toggle('active');
                });
                
                // Close button
                const closeBtn = modal.querySelector('#settingsCloseBtn');
                closeBtn.addEventListener('click', () => {
                    if (timerInterval) clearInterval(timerInterval);
                    modal.remove();
                });
                
                // Click outside to close
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        if (timerInterval) clearInterval(timerInterval);
                        modal.remove();
                    }
                });
                
                // Escape to close
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        if (timerInterval) clearInterval(timerInterval);
                        modal.remove();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
            }

            applyFontSize() {
                if (this.elements.viewer) {
                    this.elements.viewer.style.fontSize = this.fontSize + 'px';
                }
                // Also update for regular EPUBs
                if (!this.hasMediaOverlay) {
                    if (this.rendition) {
                        this.applyReaderStyles();
                    } else if (this.currentSpineIndex !== undefined) {
                        // Re-render for direct display, preserving scroll position
                        this.displayChapterDirect(this.currentSpineIndex, true);
                    }
                }
            }

            applyFontFamily() {
                if (this.elements.viewer) {
                    // Remove all font classes
                    this.elements.viewer.classList.remove('font-serif', 'font-sans', 'font-mono', 'font-dyslexic', 
                        'font-palatino', 'font-garamond', 'font-bookerly', 'font-opensans', 'font-roboto', 
                        'font-arial', 'font-verdana', 'font-atkinson');
                    // Add the selected font class
                    this.elements.viewer.classList.add(`font-${this.fontFamily}`);
                }
                // Also update for regular EPUBs
                if (!this.hasMediaOverlay) {
                    if (this.rendition) {
                        this.applyReaderStyles();
                    } else if (this.currentSpineIndex !== undefined) {
                        // Re-render for direct display, preserving scroll position
                        this.displayChapterDirect(this.currentSpineIndex, true);
                    }
                }
            }

            applyLineSpacing() {
                if (this.elements.viewer) {
                    // Remove all spacing classes
                    this.elements.viewer.classList.remove('spacing-compact', 'spacing-normal', 'spacing-relaxed', 'spacing-loose');
                    // Add the selected spacing class
                    this.elements.viewer.classList.add(`spacing-${this.lineSpacing}`);
                }
                // Also update for regular EPUBs
                if (!this.hasMediaOverlay) {
                    if (this.rendition) {
                        this.applyReaderStyles();
                    } else if (this.currentSpineIndex !== undefined) {
                        // Re-render for direct display, preserving scroll position
                        this.displayChapterDirect(this.currentSpineIndex, true);
                    }
                }
            }

            applyTextAlignment() {
                if (this.elements.viewer) {
                    // Remove all alignment classes
                    this.elements.viewer.classList.remove('align-left', 'align-justify');
                    // Add the selected alignment class
                    this.elements.viewer.classList.add(`align-${this.textAlign}`);
                }
                // Also update for regular EPUBs
                if (!this.hasMediaOverlay) {
                    if (this.rendition) {
                        this.applyReaderStyles();
                    } else if (this.currentSpineIndex !== undefined) {
                        // Re-render for direct display, preserving scroll position
                        this.displayChapterDirect(this.currentSpineIndex, true);
                    }
                }
            }

            applyPageMode() {
                if (this.pageMode === 'paginated') {
                    this.elements.readerArea.classList.add('paginated');
                    this.elements.pageNavigation.classList.add('active');
                    
                    // If we have content loaded, paginate it
                    if (!this.hasMediaOverlay) {
                        this.paginateContent();
                    }
                } else {
                    this.elements.readerArea.classList.remove('paginated');
                    this.elements.pageNavigation.classList.remove('active');
                    
                    // Restore scroll mode
                    const container = this.readerContainer || this.elements.viewer;
                    const contentElement = container?.querySelector('.chapter-content') || container;
                    
                    if (container) {
                        // Restore container styles for scrolling
                        container.style.height = '';
                        container.style.overflowY = 'auto';
                        container.style.overflow = '';
                        container.style.position = '';
                    }
                    
                    if (contentElement) {
                        // Restore original styles
                        if (this.originalStyles) {
                            contentElement.style.columnWidth = this.originalStyles.columnWidth;
                            contentElement.style.columnCount = this.originalStyles.columnCount || '';
                            contentElement.style.columnGap = this.originalStyles.columnGap;
                            contentElement.style.height = this.originalStyles.height;
                            contentElement.style.width = this.originalStyles.width;
                            contentElement.style.maxWidth = this.originalStyles.maxWidth;
                            contentElement.style.overflow = this.originalStyles.overflow;
                            contentElement.style.padding = this.originalStyles.padding;
                            contentElement.style.boxSizing = this.originalStyles.boxSizing || '';
                            this.originalStyles = null;
                        } else {
                            // Fallback if no original styles saved
                            contentElement.style.columnWidth = '';
                            contentElement.style.columnCount = '';
                            contentElement.style.columnGap = '';
                            contentElement.style.height = '';
                            contentElement.style.width = '';
                            contentElement.style.maxWidth = '';
                            contentElement.style.overflow = '';
                            contentElement.style.padding = '';
                            contentElement.style.boxSizing = '';
                        }
                        
                        contentElement.style.transform = '';
                        contentElement.style.transition = '';
                        contentElement.style.position = '';
                        contentElement.style.top = '';
                        contentElement.style.left = '';
                        contentElement.style.willChange = '';
                        
                        // Restore original content if it was modified
                        if (this.originalContent) {
                            contentElement.innerHTML = this.originalContent;
                            this.originalContent = null;
                        }
                    }
                    
                    this.elements.readerArea.style.overflow = '';
                    
                    this.currentPage = 0;
                    this.totalPages = 0;
                }
            }

            paginateContent() {
                if (!this.readerContainer && !this.elements.viewer) return;
                
                const container = this.readerContainer || this.elements.viewer;
                const readerArea = this.elements.readerArea;
                
                // Get the actual content container (with .chapter-content class for direct display)
                let contentElement = container.querySelector('.chapter-content') || container;
                
                if (!contentElement) {
                    console.error('No content element found for pagination');
                    return;
                }
                
                // Store original content and styles if not already stored
                if (!this.originalContent) {
                    this.originalContent = contentElement.innerHTML;
                    this.originalStyles = {
                        columnWidth: contentElement.style.columnWidth,
                        columnCount: contentElement.style.columnCount,
                        columnGap: contentElement.style.columnGap,
                        height: contentElement.style.height,
                        width: contentElement.style.width,
                        maxWidth: contentElement.style.maxWidth,
                        overflow: contentElement.style.overflow,
                        padding: contentElement.style.padding,
                        boxSizing: contentElement.style.boxSizing
                    };
                }
                
                // Calculate available dimensions
                const pageWidth = readerArea.clientWidth;
                const pageHeight = readerArea.clientHeight;
                
                console.log('Pagination setup:', {
                    pageWidth,
                    pageHeight,
                    readerAreaWidth: readerArea.clientWidth,
                    readerAreaHeight: readerArea.clientHeight
                });
                
                // Set up container as viewport
                container.style.height = `${pageHeight}px`;
                container.style.overflow = 'hidden';
                container.style.position = 'relative';
                
                // IMPORTANT: Use box-sizing border-box so padding is included in width/height
                // Then column-width equals the full pageWidth, and padding creates margins
                contentElement.style.boxSizing = 'border-box';
                contentElement.style.padding = '2rem';
                contentElement.style.columnWidth = `${pageWidth}px`;
                contentElement.style.columnGap = '0';
                contentElement.style.columnFill = 'auto';
                contentElement.style.height = `${pageHeight}px`;
                contentElement.style.width = 'auto';
                contentElement.style.maxWidth = 'none';
                contentElement.style.overflow = 'visible';
                contentElement.style.position = 'absolute';
                contentElement.style.top = '0';
                contentElement.style.left = '0';
                contentElement.style.transition = 'transform 0.3s ease';
                contentElement.style.willChange = 'transform';
                
                // Force reflow and measure
                setTimeout(() => {
                    const contentScrollWidth = contentElement.scrollWidth;
                    
                    console.log('Content scrollWidth:', contentScrollWidth, 'Page width:', pageWidth);
                    
                    // Calculate pages: each page is pageWidth wide
                    this.totalPages = Math.max(1, Math.ceil(contentScrollWidth / pageWidth));
                    this.currentPage = 0;
                    
                    console.log('Calculated total pages:', this.totalPages, 'Pages based on scroll:', Math.ceil(contentScrollWidth / pageWidth));
                    
                    this.displayPage(0);
                }, 100);
            }

            displayPage(pageIndex) {
                const container = this.readerContainer || this.elements.viewer;
                const contentElement = container.querySelector('.chapter-content') || container;
                
                if (!contentElement || pageIndex < 0 || pageIndex >= this.totalPages) return;
                
                this.currentPage = pageIndex;
                
                // Calculate horizontal scroll position for this page
                // Each page shift needs to account for the full viewport width
                const pageWidth = this.elements.readerArea.clientWidth;
                const scrollPosition = pageIndex * pageWidth;
                
                console.log('[PAGINATION] Displaying page:', pageIndex + 1, {
                    pageWidth,
                    scrollPosition,
                    totalPages: this.totalPages,
                    contentScrollWidth: contentElement.scrollWidth
                });
                
                // Use transform to shift the content horizontally
                contentElement.style.transform = `translateX(-${scrollPosition}px)`;
                
                // Update page info
                this.elements.pageInfo.textContent = `Page ${pageIndex + 1} of ${this.totalPages}`;
                
                // Update button states
                this.elements.prevPageBtn.disabled = pageIndex === 0;
                this.elements.nextPageBtn.disabled = pageIndex === this.totalPages - 1;
            }

            previousPage() {
                if (this.currentPage > 0) {
                    this.displayPage(this.currentPage - 1);
                } else if (this.currentSpineIndex > 0) {
                    // At first page, go to previous chapter
                    this.displayChapterDirect(this.currentSpineIndex - 1);
                }
            }

            nextPage() {
                if (this.currentPage < this.totalPages - 1) {
                    this.displayPage(this.currentPage + 1);
                } else if (this.currentSpineIndex < this.spineItems.length - 1) {
                    // At last page, go to next chapter
                    this.displayChapterDirect(this.currentSpineIndex + 1);
                }
            }

            toggleFullscreen() {
                this.isFullscreen = !this.isFullscreen;
                
                if (this.isFullscreen) {
                    this.elements.readerArea.classList.add('fullscreen');
                    // Change icon to exit fullscreen
                    this.elements.fullscreenIcon.innerHTML = '<path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" fill="currentColor"/>';
                } else {
                    this.elements.readerArea.classList.remove('fullscreen');
                    // Change icon to enter fullscreen
                    this.elements.fullscreenIcon.innerHTML = '<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" fill="currentColor"/>';
                }
            }

            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                
                if (this.isDarkMode) {
                    this.elements.readerArea.classList.add('dark-mode');
                } else {
                    this.elements.readerArea.classList.remove('dark-mode');
                }
                
                // Also update for regular EPUBs
                if (!this.hasMediaOverlay) {
                    if (this.rendition) {
                        // For rendition-based display, apply all reader styles
                        this.applyReaderStyles();
                    } else if (this.currentSpineIndex !== undefined) {
                        // Re-render for direct display with dark mode
                        this.displayChapterDirect(this.currentSpineIndex, true);
                    }
                }
            }

            addDebugInfo(info) {
                this.debugInfo.push(info);
                console.log('DEBUG:', info);
                if (this.elements.debugContent) {
                    this.updateDebugPanel();
                }
            }

            updateDebugPanel() {
                if (this.elements.debugContent) {
                    this.elements.debugContent.innerHTML = this.debugInfo
                        .map(info => `<div class="debug-item">${info}</div>`)
                        .join('');
                }
            }

            updateMediaSession() {
                if ('mediaSession' in navigator) {
                    const chapterTitle = this.elements.bookChapter.textContent;
                    
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: this.bookMetadata.title,
                        artist: this.bookMetadata.author,
                        album: chapterTitle,
                        artwork: this.bookMetadata.coverImage ? [
                            { src: this.bookMetadata.coverImage, sizes: '512x512', type: 'image/jpeg' }
                        ] : []
                    });
                    
                    navigator.mediaSession.setActionHandler('play', () => {
                        this.togglePlay();
                    });
                    
                    navigator.mediaSession.setActionHandler('pause', () => {
                        this.togglePlay();
                    });
                    
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        this.previousSegment();
                    });
                    
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        this.nextSegment();
                    });
                }
            }

            async checkMediaOverlays() {
                try {
                    await this.book.loaded.spine;
                    await this.book.loaded.metadata;
                    await this.book.loaded.manifest;
                    
                    this.overlayChapters = [];
                    const manifest = this.book.packaging.manifest;
                    
                    console.log('=== Checking for Media Overlays ===');
                    console.log('Manifest:', manifest);
                    console.log('Spine items:', this.book.spine.items);
                    
                    // NEW APPROACH: Directly check the raw packaging XML for media-overlay attributes
                    // This bypasses any ePub.js parsing issues
                    const overlayMap = new Map(); // Maps content ID to overlay ID
                    
                    // Look through manifest for items with media-overlay attributes
                    // Check multiple property name formats that ePub.js might use
                    for (const [id, item] of Object.entries(manifest)) {
                        // Log all properties to see what we're working with
                        if (id === 'p001' || id === 's001') {
                            console.log(`Detailed inspection of ${id}:`, JSON.stringify(item, null, 2));
                        }
                        
                        // Try accessing media-overlay in multiple ways
                        let overlayId = null;
                        
                        // Direct property access
                        if (item['media-overlay']) overlayId = item['media-overlay'];
                        else if (item.mediaOverlay) overlayId = item.mediaOverlay;
                        else if (item['mediaOverlay']) overlayId = item['mediaOverlay'];
                        
                        // Check in properties object if it exists
                        if (!overlayId && item.properties) {
                            if (typeof item.properties === 'string') {
                                // Sometimes properties is a space-separated string
                                const props = item.properties.split(' ');
                                // Look for media-overlay value (unlikely but check)
                            } else if (typeof item.properties === 'object') {
                                overlayId = item.properties['media-overlay'] || 
                                           item.properties.mediaOverlay ||
                                           item.properties['mediaOverlay'];
                            }
                        }
                        
                        if (overlayId) {
                            console.log(`‚úì Found media-overlay: ${id} -> ${overlayId}`);
                            overlayMap.set(id, overlayId);
                        }
                    }
                    
                    // If we didn't find any through property access, check the raw XML
                    if (overlayMap.size === 0) {
                        console.log('No overlays found via property access, checking raw packaging...');
                        
                        // Try to access the raw OPF content
                        try {
                            const opfPath = this.book.packaging.manifestPath || 'OEBPS/content.opf';
                            console.log('Trying to load OPF from:', opfPath);
                            
                            // Get the raw OPF file
                            const opfDoc = this.book.packaging.metadata.layout;
                            
                            // Alternative: Look through the archive directly
                            if (this.book.archive && this.book.archive.zip) {
                                const opfFiles = Object.keys(this.book.archive.zip.files).filter(f => 
                                    f.endsWith('.opf') || f.endsWith('content.opf')
                                );
                                
                                if (opfFiles.length > 0) {
                                    console.log('Found OPF file:', opfFiles[0]);
                                    const opfFile = this.book.archive.zip.files[opfFiles[0]];
                                    const opfText = await opfFile.async('text');
                                    
                                    // Parse the XML to find media-overlay attributes
                                    const parser = new DOMParser();
                                    const opfXml = parser.parseFromString(opfText, 'text/xml');
                                    const items = opfXml.querySelectorAll('manifest item[media-overlay]');
                                    
                                    console.log(`Found ${items.length} items with media-overlay attribute in raw XML`);
                                    
                                    items.forEach(item => {
                                        const id = item.getAttribute('id');
                                        const overlayId = item.getAttribute('media-overlay');
                                        console.log(`  ‚úì ${id} -> ${overlayId}`);
                                        overlayMap.set(id, overlayId);
                                    });
                                }
                            }
                        } catch (e) {
                            console.log('Could not access raw OPF:', e);
                        }
                    }
                    
                    console.log('Overlay map:', overlayMap);
                    
                    // Now match the overlays to spine items
                    this.book.spine.items.forEach((spineItem, index) => {
                        const spineId = spineItem.idref || spineItem.id;
                        console.log(`Spine item ${index}: id="${spineItem.id}", idref="${spineItem.idref}", href="${spineItem.href}"`);
                        
                        if (overlayMap.has(spineId)) {
                            const overlayId = overlayMap.get(spineId);
                            console.log(`  ‚úì Matched to overlay: ${overlayId}`);
                            spineItem.mediaOverlay = overlayId;
                            this.overlayChapters.push(spineItem);
                        }
                    });

                    // Find all SMIL files as backup
                    const smilFiles = [];
                    for (const [id, item] of Object.entries(manifest)) {
                        const isSmil = item['media-type'] === 'application/smil+xml' || 
                                      item.mediaType === 'application/smil+xml' ||
                                      (item.href && item.href.endsWith('.smil'));
                        
                        if (isSmil) {
                            console.log(`‚úì Found SMIL file: ${id} -> ${item.href}`);
                            smilFiles.push({ id, ...item });
                        }
                    }

                    // If still no matches, try filename-based matching
                    if (smilFiles.length > 0 && this.overlayChapters.length === 0) {
                        console.log('No direct matches, trying filename-based matching...');
                        
                        smilFiles.forEach(smilFile => {
                            // Extract base filename from SMIL
                            const smilHref = smilFile.href;
                            const smilBaseName = smilHref.split('/').pop()
                                .replace('.xhtml.smil', '')
                                .replace('.html.smil', '')
                                .replace('.smil', '');
                            
                            console.log(`Trying to match SMIL "${smilBaseName}" from "${smilHref}"`);
                            
                            const spineItem = this.book.spine.items.find(si => {
                                const spineHref = si.href;
                                const spineBaseName = spineHref.split('/').pop()
                                    .replace('.xhtml', '')
                                    .replace('.html', '');
                                
                                const match = smilBaseName === spineBaseName;
                                console.log(`  Comparing "${smilBaseName}" with "${spineBaseName}": ${match}`);
                                return match;
                            });
                            
                            if (spineItem && !spineItem.mediaOverlay) {
                                console.log(`  ‚úì Matched by filename!`);
                                spineItem.mediaOverlay = smilFile.id;
                                this.overlayChapters.push(spineItem);
                            }
                        });
                    }

                    console.log(`=== Found ${this.overlayChapters.length} chapters with media overlays ===`);

                    if (this.overlayChapters.length > 0) {
                        this.elements.chaptersBtn.disabled = false;
                        this.hasMediaOverlay = true;
                        
                        // Hide page navigation for media overlay books
                        this.elements.pageNavigation.classList.remove('active');
                        this.elements.readerArea.classList.remove('paginated');
                        
                        await this.loadChapterOverlay(this.overlayChapters[0]);
                    } else {
                        console.log('No media overlays found, loading as regular EPUB');
                        this.hasMediaOverlay = false;
                        await this.loadAsRegularEPUB();
                    }
                } catch (error) {
                    console.error('Error checking overlays:', error);
                    // Don't show error, just load as regular EPUB
                    this.hasMediaOverlay = false;
                    await this.loadAsRegularEPUB();
                }
            }

            async loadAsRegularEPUB() {
                try {
                    // Get all spine items (chapters)
                    const spine = this.book.spine;
                    const spineItems = spine.items || [];
                    
                    if (spineItems.length === 0) {
                        throw new Error('No content found in EPUB');
                    }
                    
                    // Check if we're running on file:// protocol
                    const isFileProtocol = window.location.protocol === 'file:';
                    
                    const viewerElement = this.elements.viewer;
                    if (!viewerElement) {
                        throw new Error('Viewer element not found');
                    }
                    
                    viewerElement.innerHTML = ''; // Clear any existing content
                    
                    if (isFileProtocol) {
                        // For file:// protocol, use a simpler display method
                        // Create a container for manual chapter display
                        const readerContainer = document.createElement('div');
                        readerContainer.id = 'epub-reader-container';
                        const containerOverflow = this.pageMode === 'paginated' ? 'hidden' : 'auto';
                        readerContainer.style.cssText = `
                            width: 100%;
                            height: 100%;
                            overflow-y: ${containerOverflow};
                            padding: 2rem;
                            background: white;
                            color: black;
                        `;
                        viewerElement.appendChild(readerContainer);
                        
                        // Store for navigation
                        this.currentSpineIndex = 0;
                        this.spineItems = spineItems;
                        this.readerContainer = readerContainer;
                        
                        // Restore saved progress if available
                        const bookData = this.libraryManager.getBook(this.currentBookId);
                        let startChapter = 0;
                        if (bookData && bookData.progress && bookData.progress.chapterIndex !== undefined) {
                            startChapter = Math.min(bookData.progress.chapterIndex, spineItems.length - 1);
                            console.log('Restoring progress to chapter:', startChapter + 1, 'of', spineItems.length);
                        }
                        
                        // Load chapter at saved position
                        await this.displayChapterDirect(startChapter);
                        
                    } else {
                        // For http:// or https://, use epub.js rendition
                        // Create a dedicated container for the rendition
                        const renditionContainer = document.createElement('div');
                        renditionContainer.id = 'epub-rendition-container';
                        renditionContainer.style.cssText = `
                            width: 100%;
                            height: 100%;
                            overflow: hidden;
                        `;
                        viewerElement.appendChild(renditionContainer);
                        
                        this.rendition = this.book.renderTo(renditionContainer, {
                            width: '100%',
                            height: '100%',
                            spread: 'none',
                            flow: 'paginated',
                            overflow: 'hidden'
                        });
                        
                        // Register themes BEFORE displaying
                        const fontSize = this.fontSize || 18;
                        const fontFamilyCSS = this.getFontFamilyCSS();
                        const textAlign = this.textAlign || 'left';
                        const lineHeight = this.getLineHeight();
                        const bgColor = this.isDarkMode ? '#1a1a1a' : '#ffffff';
                        const textColor = this.isDarkMode ? '#e0e0e0' : '#1e293b';
                        
                        this.rendition.themes.register('custom', {
                            'body': {
                                'font-size': fontSize + 'px !important',
                                'font-family': fontFamilyCSS + ' !important',
                                'text-align': textAlign + ' !important',
                                'line-height': lineHeight + ' !important',
                                'padding': '2rem !important',
                                'max-width': '800px !important',
                                'margin': '0 auto !important',
                                'background': bgColor + ' !important',
                                'color': textColor + ' !important'
                            },
                            'p': {
                                'margin-bottom': '1.25rem !important',
                                'text-align': textAlign + ' !important'
                            },
                            'h1, h2, h3, h4, h5, h6': {
                                'margin-top': '2rem !important',
                                'margin-bottom': '1rem !important',
                                'color': textColor + ' !important'
                            }
                        });
                        
                        this.rendition.themes.select('custom');
                        
                        // Generate locations for progress calculation (this takes a moment)
                        try {
                            await this.book.locations.generate(1024);
                            console.log('Locations generated:', this.book.locations.total);
                        } catch (error) {
                            console.warn('Could not generate locations:', error);
                        }
                        
                        // Wait for rendition to be ready
                        await this.rendition.display();
                        
                        // Store spine items for navigation
                        this.spineItems = spineItems;
                        
                        // Restore saved progress for regular EPUBs
                        const bookData = this.libraryManager.getBook(this.currentBookId);
                        if (bookData && bookData.progress && bookData.progress.cfi) {
                            try {
                                console.log('Restoring progress to CFI:', bookData.progress.cfi);
                                await this.rendition.display(bookData.progress.cfi);
                            } catch (error) {
                                console.error('Error restoring progress:', error);
                                // If restoration fails, just stay at the beginning
                            }
                        }
                        
                        // Track location changes for progress saving
                        this.rendition.on('relocated', (location) => {
                            console.log('Relocated event fired:', location);
                            this.saveRegularEPUBProgress(location);
                        });
                    }
                    
                    // Hide media controls
                    this.elements.statusBar.style.display = 'none';
                    this.elements.playBtn.disabled = true;
                    this.elements.prevBtn.disabled = true;
                    this.elements.nextBtn.disabled = true;
                    
                    // Set up navigation
                    this.setupRegularEPUBNavigation();
                    
                    // Enable chapters button for TOC
                    this.elements.chaptersBtn.disabled = false;
                    
                    // Show book title
                    const bookData = this.libraryManager.getBook(this.currentBookId);
                    if (bookData) {
                        this.elements.bookChapter.textContent = bookData.title;
                    }
                    
                    this.showNotification('Book loaded successfully', 'success');
                    
                    // Apply page mode if in paginated mode (after content is loaded)
                    if (this.pageMode === 'paginated') {
                        setTimeout(() => {
                            this.applyPageMode();
                        }, 500);
                    }
                    
                } catch (error) {
                    console.error('Error loading regular EPUB:', error);
                    this.showNotification('Error loading book: ' + error.message, 'error');
                }
            }
            
            async displayChapterDirect(index, preserveScroll = false) {
                console.log('[DEBUG] displayChapterDirect called:', { index, preserveScroll, hasSpineItems: !!this.spineItems, hasReaderContainer: !!this.readerContainer });
                
                if (!this.spineItems || index < 0 || index >= this.spineItems.length) {
                    console.error('[DEBUG] displayChapterDirect: Invalid state', {
                        spineItems: this.spineItems?.length,
                        index,
                        hasReaderContainer: !!this.readerContainer
                    });
                    return;
                }
                
                try {
                    console.log('[DEBUG] Loading chapter', this.spineItems[index].href);
                    
                    // Save scroll position if needed
                    const scrollPosition = preserveScroll && this.readerContainer ? this.readerContainer.scrollTop : 0;
                    
                    this.currentSpineIndex = index;
                    const spineItem = this.spineItems[index];
                    
                    // Load the chapter content
                    const doc = await this.book.load(spineItem.href);
                    
                    console.log('[DEBUG] Chapter loaded, doc type:', doc?.constructor?.name);
                    
                    // Extract the HTML content properly
                    let htmlContent = '';
                    if (doc instanceof XMLDocument || doc instanceof Document) {
                        // Get the body content if it exists, otherwise get the whole document
                        const bodyElement = doc.querySelector('body');
                        if (bodyElement) {
                            htmlContent = bodyElement.innerHTML;
                            console.log('[DEBUG] Extracted from body, length:', htmlContent.length);
                        } else {
                            // If no body, try to serialize the whole document
                            const serializer = new XMLSerializer();
                            htmlContent = serializer.serializeToString(doc);
                            console.log('[DEBUG] Serialized document, length:', htmlContent.length);
                        }
                    } else if (typeof doc === 'string') {
                        htmlContent = doc;
                        console.log('[DEBUG] String content, length:', htmlContent.length);
                    } else {
                        htmlContent = String(doc);
                        console.log('[DEBUG] Converted to string, length:', htmlContent.length);
                    }
                    
                    if (!htmlContent) {
                        console.error('[DEBUG] No HTML content extracted!');
                    }
                    
                    // Apply current styles
                    const fontSize = this.fontSize || 18;
                    const fontFamily = this.getFontFamilyCSS();
                    const textAlign = this.textAlign || 'left';
                    const lineHeight = this.getLineHeight();
                    
                    // Dark mode colors
                    const bgColor = this.isDarkMode ? '#1a1a1a' : '#ffffff';
                    const textColor = this.isDarkMode ? '#e0e0e0' : '#1a1a1a';
                    const linkColor = this.isDarkMode ? '#60a5fa' : '#2563eb';
                    
                    console.log('[DEBUG] Rendering to readerContainer');
                    
                    this.readerContainer.innerHTML = `
                        <style>
                            .chapter-content {
                                font-size: ${fontSize}px !important;
                                font-family: ${fontFamily} !important;
                                text-align: ${textAlign} !important;
                                line-height: ${lineHeight} !important;
                                background: ${bgColor} !important;
                                color: ${textColor} !important;
                                padding: 2rem;
                            }
                            .chapter-content * {
                                font-size: inherit !important;
                                font-family: inherit !important;
                                line-height: inherit !important;
                                color: ${textColor} !important;
                            }
                            .chapter-content a {
                                color: ${linkColor} !important;
                            }
                            .chapter-content img {
                                max-width: 100%;
                                height: auto;
                            }
                            .chapter-content p {
                                margin-bottom: 1em;
                                text-align: ${textAlign} !important;
                            }
                            .chapter-content h1, 
                            .chapter-content h2, 
                            .chapter-content h3,
                            .chapter-content h4,
                            .chapter-content h5,
                            .chapter-content h6 {
                                margin-top: 1.5em;
                                margin-bottom: 0.5em;
                                font-weight: bold;
                                text-align: ${textAlign} !important;
                            }
                            .chapter-content h1 { font-size: 2em !important; }
                            .chapter-content h2 { font-size: 1.5em !important; }
                            .chapter-content h3 { font-size: 1.3em !important; }
                            .chapter-content div,
                            .chapter-content span {
                                text-align: inherit !important;
                            }
                        </style>
                        <div class="chapter-content">
                            ${htmlContent}
                        </div>
                    `;
                    
                    console.log('[DEBUG] Content rendered to innerHTML');
                    
                    // Also update the container background
                    this.readerContainer.style.background = bgColor;
                    
                    // Restore or reset scroll position
                    if (preserveScroll) {
                        this.readerContainer.scrollTop = scrollPosition;
                    } else {
                        this.readerContainer.scrollTop = 0;
                    }
                    
                    // Update chapter title
                    const chapterTitle = await this.extractChapterTitle(spineItem);
                    this.elements.bookChapter.textContent = chapterTitle;
                    
                    // Reset pagination state for new chapter
                    this.originalContent = null;
                    this.originalStyles = null;
                    this.currentPage = 0;
                    this.totalPages = 0;
                    
                    // Apply pagination if in paginated mode
                    if (this.pageMode === 'paginated') {
                        this.paginateContent();
                    }
                    
                    // Save progress for direct display mode
                    this.saveDirectDisplayProgress();
                    
                    console.log('[DEBUG] displayChapterDirect complete');
                    
                } catch (error) {
                    console.error('Error displaying chapter:', error);
                    this.showNotification('Error loading chapter', 'error');
                }
            }
            
            getFontFamilyCSS() {
                const fontFamily = this.fontFamily || 'serif';
                switch (fontFamily) {
                    case 'sans': return '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    case 'serif': return 'Georgia, "Times New Roman", serif';
                    case 'palatino': return '"Palatino Linotype", "Book Antiqua", Palatino, serif';
                    case 'garamond': return 'Garamond, "Adobe Garamond Pro", serif';
                    case 'bookerly': return 'Bookerly, Georgia, serif';
                    case 'opensans': return '"Open Sans", sans-serif';
                    case 'roboto': return 'Roboto, sans-serif';
                    case 'arial': return 'Arial, Helvetica, sans-serif';
                    case 'verdana': return 'Verdana, Geneva, sans-serif';
                    case 'mono': return '"Courier New", Courier, monospace';
                    case 'dyslexic': return 'OpenDyslexic, sans-serif';
                    case 'atkinson': return '"Atkinson Hyperlegible", sans-serif';
                    default: return 'Georgia, serif';
                }
            }
            
            setupRegularEPUBNavigation() {
                const isFileProtocol = window.location.protocol === 'file:';
                
                if (isFileProtocol) {
                    // Navigation with arrow keys for direct display
                    const keyHandler = (e) => {
                        if (e.key === 'ArrowLeft') {
                            this.previousChapter();
                        } else if (e.key === 'ArrowRight') {
                            this.nextChapter();
                        }
                    };
                    
                    document.removeEventListener('keydown', keyHandler);
                    document.addEventListener('keydown', keyHandler);
                    
                } else if (this.rendition) {
                    // Navigation with arrow keys for rendition
                    const keyHandler = (e) => {
                        if (e.key === 'ArrowLeft') {
                            this.rendition.prev();
                        } else if (e.key === 'ArrowRight') {
                            this.rendition.next();
                        }
                    };
                    
                    document.removeEventListener('keydown', keyHandler);
                    document.addEventListener('keydown', keyHandler);
                    
                    // Click navigation on the viewer
                    this.rendition.on('click', (event) => {
                        const clickX = event.clientX;
                        const width = window.innerWidth;
                        
                        if (clickX < width / 3) {
                            this.rendition.prev();
                        } else if (clickX > (2 * width) / 3) {
                            this.rendition.next();
                        }
                    });
                }
            }
            
            previousChapter() {
                if (this.currentSpineIndex > 0) {
                    this.displayChapterDirect(this.currentSpineIndex - 1);
                }
            }
            
            nextChapter() {
                if (this.currentSpineIndex < this.spineItems.length - 1) {
                    this.displayChapterDirect(this.currentSpineIndex + 1);
                }
            }
            
            applyReaderStyles() {
                const isFileProtocol = window.location.protocol === 'file:';
                
                if (isFileProtocol && this.currentSpineIndex !== undefined) {
                    // Re-render current chapter with new styles for direct display
                    this.displayChapterDirect(this.currentSpineIndex, true);
                } else if (this.rendition) {
                    // Update the custom theme without re-displaying
                    const fontSize = this.fontSize || 18;
                    const fontFamily = this.fontFamily || 'serif';
                    const textAlign = this.textAlign || 'left';
                    const lineHeight = this.getLineHeight();
                    
                    const fontFamilyCSS = this.getFontFamilyCSS();
                    
                    const bgColor = this.isDarkMode ? '#1a1a1a' : '#ffffff';
                    const textColor = this.isDarkMode ? '#e0e0e0' : '#1e293b';
                    
                    // Override the custom theme
                    this.rendition.themes.override('custom', {
                        'body': {
                            'font-size': fontSize + 'px !important',
                            'font-family': fontFamilyCSS + ' !important',
                            'text-align': textAlign + ' !important',
                            'line-height': lineHeight + ' !important',
                            'padding': '2rem !important',
                            'max-width': '800px !important',
                            'margin': '0 auto !important',
                            'background': bgColor + ' !important',
                            'color': textColor + ' !important'
                        },
                        'p': {
                            'margin-bottom': '1.25rem !important',
                            'text-align': textAlign + ' !important'
                        },
                        'h1, h2, h3, h4, h5, h6': {
                            'margin-top': '2rem !important',
                            'margin-bottom': '1rem !important',
                            'color': textColor + ' !important'
                        }
                    });
                }
            }
            
            getLineHeight() {
                const spacing = this.lineSpacing || 'normal';
                switch (spacing) {
                    case 'compact': return '1.4';
                    case 'normal': return '1.6';
                    case 'relaxed': return '1.8';
                    case 'loose': return '2.0';
                    default: return '1.6';
                }
            }

            async loadChapterOverlay(spineItem) {
                try {
                    if (this.isPlaying) {
                        this.controller.pause();
                        this.isPlaying = false;
                        this.elements.playBtn.innerHTML = '<span class="btn-icon">‚ñ∂</span>';
                        this.elements.playBtn.classList.remove('playing');
                    }
                    
                    this.controller.clearCache();
                    this.clearHighlight();
                    
                    let overlayRef = spineItem.mediaOverlay;
                    
                    if (!overlayRef) return;

                    const manifestItem = this.book.packaging.manifest[overlayRef];
                    if (!manifestItem) return;

                    const overlayHref = manifestItem.href;
                    const smilUrl = this.book.path.resolve(overlayHref);
                    const smilContent = await this.book.load(smilUrl);
                    
                    this.segments = await this.parser.parse(smilContent);
                    this.currentSegmentIndex = 0;
                    this.currentChapter = spineItem;
                    
                    this.controller.setSegments(this.segments);
                    this.controller.currentSegmentIndex = 0;

                    await this.resolveAudioPaths(overlayHref);
                    await this.displayChapterContent(spineItem);

                    const chapterTitle = await this.extractChapterTitle(spineItem);
                    
                    // Display just the chapter title
                    this.elements.bookChapter.textContent = chapterTitle;
                    
                    this.elements.statusBar.style.display = 'flex';
                    this.elements.playBtn.disabled = false;
                    this.elements.prevBtn.disabled = false;
                    this.elements.nextBtn.disabled = false;
                    
                    this.updateMediaSession();
                    // Don't save progress here - it will overwrite saved position during resume

                } catch (error) {
                    console.error('Error loading chapter overlay:', error);
                    this.showNotification('Error loading media overlay: ' + error.message, 'error');
                }
            }

            async extractChapterTitle(spineItem) {
                try {
                    // First try to get the title from TOC
                    const navigation = await this.book.loaded.navigation;
                    const toc = navigation.toc;
                    
                    // Recursive function to search TOC for matching href
                    const findInToc = (items, targetHref) => {
                        for (const item of items) {
                            const itemBase = item.href.split('#')[0];
                            const targetBase = targetHref.split('#')[0];
                            
                            if (itemBase.includes(targetBase) || targetBase.includes(itemBase)) {
                                return item.label;
                            }
                            
                            if (item.subitems && item.subitems.length > 0) {
                                const found = findInToc(item.subitems, targetHref);
                                if (found) return found;
                            }
                        }
                        return null;
                    };
                    
                    const tocTitle = findInToc(toc, spineItem.href);
                    if (tocTitle) {
                        return tocTitle;
                    }
                    
                    // Fallback to extracting from HTML content
                    const chapterPath = spineItem.href;
                    const archiveFiles = Object.keys(this.book.archive.zip.files);
                    let actualPath = null;
                    
                    if (this.book.archive.zip.files[chapterPath]) {
                        actualPath = chapterPath;
                    } else {
                        const fileName = chapterPath.split('/').pop();
                        actualPath = archiveFiles.find(f => f.endsWith(fileName));
                    }
                    
                    if (actualPath) {
                        const zipFile = this.book.archive.zip.files[actualPath];
                        const content = await zipFile.async('text');
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(content, 'text/html');
                        
                        const titleElement = doc.querySelector('title') || 
                                            doc.querySelector('h1') || 
                                            doc.querySelector('h2');
                        
                        if (titleElement && titleElement.textContent.trim()) {
                            return titleElement.textContent.trim();
                        }
                    }
                } catch (e) {
                    console.log('Could not extract chapter title:', e);
                }
                
                return `Chapter ${spineItem.index + 1}`;
            }

            async displayChapterContent(spineItem) {
                try {
                    const chapterPath = spineItem.href;
                    const archiveFiles = Object.keys(this.book.archive.zip.files);
                    let actualPath = null;
                    
                    if (this.book.archive.zip.files[chapterPath]) {
                        actualPath = chapterPath;
                    } else {
                        const fileName = chapterPath.split('/').pop();
                        actualPath = archiveFiles.find(f => f.endsWith(fileName));
                    }
                    
                    if (!actualPath) {
                        this.showNotification('Could not find chapter file', 'error');
                        return;
                    }
                    
                    const zipFile = this.book.archive.zip.files[actualPath];
                    const content = await zipFile.async('text');
                    
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'text/html');
                    
                    const body = doc.body;
                    if (body && body.innerHTML) {
                        this.elements.viewer.innerHTML = body.innerHTML;
                    } else {
                        this.elements.viewer.innerHTML = content;
                    }
                    
                    await this.loadImages(actualPath);
                    this.attachSegmentClickHandlers();
                    this.elements.readerArea.scrollTop = 0;
                    
                } catch (error) {
                    console.error('Error displaying chapter:', error);
                    this.showNotification('Error displaying chapter content: ' + error.message, 'error');
                }
            }

            attachSegmentClickHandlers() {
                // Add click handlers to all segments
                this.segments.forEach((segment, index) => {
                    // Extract the fragment ID from textSrc (e.g., "chapter1.xhtml#segment1" -> "segment1")
                    const fragmentMatch = segment.textSrc.match(/#(.+)$/);
                    if (!fragmentMatch) return;
                    
                    const fragmentId = fragmentMatch[1];
                    
                    // Use CSS.escape to handle IDs with special characters like periods, colons, etc.
                    let element;
                    try {
                        const escapedId = CSS.escape(fragmentId);
                        element = this.elements.viewer.querySelector(`#${escapedId}`);
                    } catch (e) {
                        console.warn(`Could not find element with ID: ${fragmentId}`, e);
                        return;
                    }
                    
                    if (element) {
                        element.style.cursor = 'pointer';
                        element.title = 'Click to play from here';
                        
                        // Store the segment index on the element
                        element.dataset.segmentIndex = index;
                        
                        // Add click handler
                        element.addEventListener('click', async (e) => {
                            e.preventDefault();
                            const segmentIndex = parseInt(e.currentTarget.dataset.segmentIndex);
                            await this.jumpToSegment(segmentIndex);
                        });
                    }
                });
            }

            async jumpToSegment(segmentIndex) {
                if (segmentIndex < 0 || segmentIndex >= this.segments.length) {
                    return;
                }
                
                // Stop current playback if playing
                if (this.isPlaying) {
                    this.controller.pause();
                    this.isPlaying = false;
                    this.elements.playBtn.innerHTML = '<span class="btn-icon">‚ñ∂</span>';
                    this.elements.playBtn.classList.remove('playing');
                }
                
                // Jump to the segment
                this.currentSegmentIndex = segmentIndex;
                this.controller.currentSegmentIndex = segmentIndex;
                
                // Clear previous highlight
                this.clearHighlight();
                
                // Highlight the clicked segment
                const segment = this.segments[segmentIndex];
                this.highlightSegment(segment);
                
                // Save progress
                this.saveProgress();
                
                // Show notification
                const percentage = Math.round((segmentIndex / this.segments.length) * 100);
                this.showNotification(`Jumped to ${percentage}% of chapter`, 'info');
                
                // Auto-play from this position
                try {
                    const blobUrl = this.audioBlobUrls.get(segment.audioSrc);
                    
                    if (!blobUrl) {
                        throw new Error(`Audio file not loaded: ${segment.audioSrc}`);
                    }
                    
                    await this.controller.loadSegment(segment, '', blobUrl);
                    this.controller.play();
                    this.isPlaying = true;
                    this.elements.playBtn.innerHTML = '<span class="btn-icon">‚è∏</span>';
                    this.elements.playBtn.classList.add('playing');
                    
                } catch (error) {
                    console.error('Error playing from segment:', error);
                    this.showNotification('Error: ' + error.message, 'error');
                }
            }

            async loadImages(chapterPath) {
                try {
                    const images = this.elements.viewer.querySelectorAll('img');
                    const chapterDir = chapterPath.substring(0, chapterPath.lastIndexOf('/') + 1);
                    
                    for (const img of images) {
                        const originalSrc = img.getAttribute('src');
                        if (!originalSrc) continue;
                        
                        if (originalSrc.startsWith('blob:') || originalSrc.startsWith('http')) {
                            continue;
                        }
                        
                        try {
                            let imagePath = originalSrc;
                            
                            if (originalSrc.startsWith('../')) {
                                const upLevels = (originalSrc.match(/\.\.\//g) || []).length;
                                const cleanPath = originalSrc.replace(/\.\.\//g, '');
                                const dirParts = chapterDir.split('/').filter(p => p);
                                const baseParts = dirParts.slice(0, Math.max(0, dirParts.length - upLevels));
                                imagePath = baseParts.join('/') + '/' + cleanPath;
                            } else if (!originalSrc.startsWith('/')) {
                                imagePath = chapterDir + originalSrc;
                            }
                            
                            const archiveFiles = Object.keys(this.book.archive.zip.files);
                            let actualImagePath = null;
                            
                            if (this.book.archive.zip.files[imagePath]) {
                                actualImagePath = imagePath;
                            } else {
                                const imageFilename = imagePath.split('/').pop();
                                actualImagePath = archiveFiles.find(f => 
                                    f.toLowerCase().endsWith(imageFilename.toLowerCase())
                                );
                            }
                            
                            if (actualImagePath) {
                                const imageFile = this.book.archive.zip.files[actualImagePath];
                                const imageData = await imageFile.async('arraybuffer');
                                
                                const extension = actualImagePath.split('.').pop().toLowerCase();
                                const mimeTypes = {
                                    'jpg': 'image/jpeg',
                                    'jpeg': 'image/jpeg',
                                    'png': 'image/png',
                                    'gif': 'image/gif',
                                    'svg': 'image/svg+xml',
                                    'webp': 'image/webp'
                                };
                                const mimeType = mimeTypes[extension] || 'image/jpeg';
                                
                                const blob = new Blob([imageData], { type: mimeType });
                                const blobUrl = URL.createObjectURL(blob);
                                
                                img.src = blobUrl;
                            }
                        } catch (error) {
                            console.error(`Error loading image ${originalSrc}:`, error);
                        }
                    }
                } catch (error) {
                    console.error('Error loading images:', error);
                }
            }

            async resolveAudioPaths(smilHref) {
                const smilDir = smilHref.substring(0, smilHref.lastIndexOf('/') + 1);
                const archiveFiles = this.book.archive && this.book.archive.zip ? 
                    Object.keys(this.book.archive.zip.files) : [];
                
                const uniqueAudioFiles = new Set();
                this.segments.forEach(seg => uniqueAudioFiles.add(seg.audioSrc));
                
                this.audioBlobUrls = new Map();
                
                for (const audioPath of uniqueAudioFiles) {
                    try {
                        const pathsToTry = [];
                        const filename = audioPath.split('/').pop();
                        
                        const audioFilesInArchive = archiveFiles.filter(f => 
                            f.toLowerCase().endsWith(filename.toLowerCase())
                        );
                        
                        if (audioFilesInArchive.length > 0) {
                            pathsToTry.push(audioFilesInArchive[0]);
                        } else {
                            pathsToTry.push(`Audio/${filename}`);
                            pathsToTry.push(`OEBPS/Audio/${filename}`);
                            pathsToTry.push(`OPS/Audio/${filename}`);
                        }
                        
                        let audioData = null;
                        let successPath = null;
                        
                        for (const path of pathsToTry) {
                            try {
                                if (this.book.archive.zip && this.book.archive.zip.files[path]) {
                                    const zipFile = this.book.archive.zip.files[path];
                                    const data = await zipFile.async('arraybuffer');
                                    audioData = data;
                                    successPath = path;
                                    break;
                                }
                            } catch (e) {
                                // Try next path
                            }
                        }
                        
                        if (!audioData) {
                            continue;
                        }
                        
                        const extension = successPath.split('.').pop().toLowerCase();
                        const mimeTypes = {
                            'mp3': 'audio/mpeg',
                            'mp4': 'audio/mp4',
                            'm4a': 'audio/mp4',
                            'wav': 'audio/wav',
                            'ogg': 'audio/ogg'
                        };
                        const mimeType = mimeTypes[extension] || 'audio/mp4';
                        
                        const blob = new Blob([audioData], { type: mimeType });
                        
                        if (blob.size === 0) {
                            continue;
                        }
                        
                        const blobUrl = URL.createObjectURL(blob);
                        this.audioBlobUrls.set(audioPath, blobUrl);
                        
                    } catch (error) {
                        console.error(`Error loading audio ${audioPath}:`, error);
                    }
                }
                
                if (this.audioBlobUrls.size === 0) {
                    this.showNotification('Could not load audio files', 'error');
                }
            }

            async togglePlay() {
                if (this.segments.length === 0) {
                    this.showNotification('No audio segments loaded', 'error');
                    return;
                }

                if (!this.isPlaying) {
                    const segment = this.segments[this.currentSegmentIndex];
                    
                    try {
                        const blobUrl = this.audioBlobUrls.get(segment.audioSrc);
                        
                        if (!blobUrl) {
                            throw new Error(`Audio file not loaded: ${segment.audioSrc}`);
                        }
                        
                        await this.controller.loadSegment(segment, '', blobUrl);
                        this.highlightSegment(segment);
                        this.controller.play();
                        this.isPlaying = true;
                        this.elements.playBtn.innerHTML = '<span class="btn-icon">‚è∏</span>';
                        this.elements.playBtn.classList.add('playing');
                        
                    } catch (error) {
                        console.error('Error playing:', error);
                        this.showNotification('Error: ' + error.message, 'error');
                    }
                } else {
                    this.controller.pause();
                    this.isPlaying = false;
                    this.elements.playBtn.innerHTML = '<span class="btn-icon">‚ñ∂</span>';
                    this.elements.playBtn.classList.remove('playing');
                    this.saveProgress();
                }
            }

            async previousSegment() {
                if (this.currentSegmentIndex > 0) {
                    this.currentSegmentIndex--;
                    await this.playCurrentSegment();
                }
            }

            async nextSegment() {
                if (this.currentSegmentIndex < this.segments.length - 1) {
                    this.currentSegmentIndex++;
                    await this.playCurrentSegment();
                }
            }

            async handleNext() {
                if (this.currentSegmentIndex < this.segments.length - 1) {
                    this.currentSegmentIndex++;
                    await this.playCurrentSegment();
                } else {
                    this.isPlaying = false;
                    this.elements.playBtn.innerHTML = '<span class="btn-icon">‚ñ∂</span>';
                    this.clearHighlight();
                    
                    const currentChapterIndex = this.overlayChapters.findIndex(
                        ch => ch.href === this.currentChapter.href
                    );
                    
                    if (currentChapterIndex !== -1 && currentChapterIndex < this.overlayChapters.length - 1) {
                        const nextChapter = this.overlayChapters[currentChapterIndex + 1];
                        
                        this.showNotification(`Loading next chapter...`, 'info');
                        
                        await this.loadChapterOverlay(nextChapter);
                        
                        setTimeout(() => {
                            this.currentSegmentIndex = 0;
                            this.isPlaying = true;
                            this.elements.playBtn.innerHTML = '<span class="btn-icon">‚è∏</span>';
                            this.playCurrentSegment();
                        }, 500);
                    } else {
                        this.showNotification('Finished all chapters!', 'success');
                        this.saveProgress();
                    }
                }
            }

            async playCurrentSegment() {
                if (!this.isPlaying) return;

                const segment = this.segments[this.currentSegmentIndex];
                
                try {
                    this.clearHighlight();
                    
                    const blobUrl = this.audioBlobUrls.get(segment.audioSrc);
                    if (!blobUrl) {
                        throw new Error(`Audio file not loaded: ${segment.audioSrc}`);
                    }
                    
                    await this.controller.loadSegment(segment, '', blobUrl);
                    this.highlightSegment(segment);
                    this.controller.play();
                } catch (error) {
                    this.showNotification('Error: ' + error.message, 'error');
                }
            }

            highlightSegment(segment) {
                const fragmentMatch = segment.textSrc.match(/#(.+)$/);
                if (!fragmentMatch) return;

                const fragmentId = fragmentMatch[1];
                
                // Use CSS.escape to handle IDs with special characters
                let element;
                try {
                    const escapedId = CSS.escape(fragmentId);
                    element = this.elements.viewer.querySelector(`#${escapedId}`);
                } catch (e) {
                    console.warn(`Could not find element with ID: ${fragmentId}`, e);
                    return;
                }
                
                if (element) {
                    this.clearHighlight();
                    element.classList.add('epub-media-overlay-active');
                    
                    const readerArea = this.elements.readerArea;
                    const elementTop = element.offsetTop;
                    const viewportHeight = readerArea.clientHeight;
                    const targetScroll = elementTop - (viewportHeight / 3);
                    
                    readerArea.scrollTo({
                        top: targetScroll,
                        behavior: 'smooth'
                    });
                }
            }

            clearHighlight() {
                const highlighted = this.elements.viewer.querySelectorAll('.epub-media-overlay-active');
                highlighted.forEach(el => el.classList.remove('epub-media-overlay-active'));
            }

            setSpeed(value) {
                const speed = parseFloat(value);
                this.controller.setPlaybackRate(speed);
            }

            async showAudioChapters() {
                if (!this.book) {
                    alert('No book loaded');
                    return;
                }

                // Get the navigation from the EPUB using ePub.js
                const navigation = await this.book.loaded.navigation;
                const toc = navigation.toc;

                if (!toc || toc.length === 0) {
                    alert('No table of contents available');
                    return;
                }

                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 1rem;
                `;

                const chaptersContainer = document.createElement('div');
                chaptersContainer.style.cssText = `
                    background: #1e293b;
                    border-radius: 1rem;
                    padding: 2rem;
                    max-width: 700px;
                    width: 100%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
                `;

                const header = document.createElement('div');
                header.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 1.5rem;
                `;

                const title = document.createElement('h2');
                title.textContent = 'Table of Contents';
                title.style.cssText = `
                    color: #f8fafc;
                    font-size: 1.5rem;
                    font-weight: 700;
                    margin: 0;
                `;

                const closeXBtn = document.createElement('button');
                closeXBtn.textContent = '‚úï';
                closeXBtn.style.cssText = `
                    background: transparent;
                    border: none;
                    color: #cbd5e1;
                    font-size: 1.5rem;
                    cursor: pointer;
                    padding: 0.25rem;
                    width: 2rem;
                    height: 2rem;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 0.375rem;
                    transition: all 0.2s;
                `;
                closeXBtn.addEventListener('mouseenter', () => {
                    closeXBtn.style.background = '#334155';
                    closeXBtn.style.color = '#f8fafc';
                });
                closeXBtn.addEventListener('mouseleave', () => {
                    closeXBtn.style.background = 'transparent';
                    closeXBtn.style.color = '#cbd5e1';
                });
                closeXBtn.addEventListener('click', () => modal.remove());

                header.appendChild(title);
                header.appendChild(closeXBtn);
                chaptersContainer.appendChild(header);

                const chaptersList = document.createElement('div');
                chaptersList.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 0.5rem;
                `;

                let currentChapterElement = null;

                // Recursive function to render TOC items with proper nesting
                const renderTocItems = (items, level = 0) => {
                    for (const item of items) {
                        const itemDiv = document.createElement('button');
                        
                        // Clean up the label for display
                        const itemLabel = item.label || 'Untitled';
                        
                        itemDiv.innerHTML = `
                            <div style="font-weight: ${level === 0 ? '600' : '500'};">${itemLabel}</div>
                        `;
                        
                        itemDiv.style.cssText = `
                            background: #0f172a;
                            color: #f8fafc;
                            border: 1px solid #334155;
                            padding: 1rem;
                            padding-left: ${1 + (level * 1.5)}rem;
                            border-radius: 0.5rem;
                            cursor: pointer;
                            text-align: left;
                            transition: all 0.2s;
                            width: 100%;
                        `;

                        // Check if this is the current chapter
                        let isCurrentChapter = false;
                        if (this.currentChapter) {
                            const currentBase = this.currentChapter.href.split('#')[0];
                            const itemBase = item.href.split('#')[0];
                            isCurrentChapter = currentBase.includes(itemBase) || itemBase.includes(currentBase);
                        }
                        
                        if (isCurrentChapter) {
                            itemDiv.style.borderColor = '#2563eb';
                            itemDiv.style.background = '#1e3a8a';
                            itemDiv.style.boxShadow = '0 0 20px rgba(37, 99, 235, 0.5)';
                            
                            // Add a "current" indicator
                            itemDiv.innerHTML = `
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="color: #60a5fa; font-size: 1.2em;">‚ñ∂</span>
                                    <div style="font-weight: ${level === 0 ? '600' : '500'};">${itemLabel}</div>
                                </div>
                            `;
                            
                            // Store reference to scroll to later
                            currentChapterElement = itemDiv;
                        }

                        itemDiv.addEventListener('mouseenter', () => {
                            if (!isCurrentChapter) {
                                itemDiv.style.background = '#334155';
                            }
                            itemDiv.style.transform = 'translateX(4px)';
                        });

                        itemDiv.addEventListener('mouseleave', () => {
                            if (isCurrentChapter) {
                                itemDiv.style.background = '#1e3a8a';
                            } else {
                                itemDiv.style.background = '#0f172a';
                            }
                            itemDiv.style.transform = 'translateX(0)';
                        });

                        itemDiv.addEventListener('click', async () => {
                            modal.remove();
                            try {
                                const isFileProtocol = window.location.protocol === 'file:';
                                
                                // Check if this is a regular EPUB or media overlay EPUB
                                if (this.hasMediaOverlay) {
                                    // Media overlay navigation
                                    const baseHref = item.href.split('#')[0];
                                    
                                    // Find the matching spine item from overlayChapters
                                    let matchingChapter = this.overlayChapters.find(ch => {
                                        const chapterBase = ch.href.split('#')[0];
                                        return baseHref.includes(chapterBase) || chapterBase.includes(baseHref);
                                    });
                                    
                                    // If not found in overlay chapters, try to find in all spine items
                                    if (!matchingChapter) {
                                        const spine = this.book.spine.items || this.book.spine;
                                        matchingChapter = spine.find(spineItem => {
                                            const spineBase = spineItem.href.split('#')[0];
                                            return baseHref.includes(spineBase) || spineBase.includes(baseHref);
                                        });
                                    }
                                    
                                    if (matchingChapter) {
                                        await this.loadChapterOverlay(matchingChapter);
                                        console.log(`Navigated to: ${itemLabel}`);
                                    } else {
                                        console.warn(`Could not find spine item for: ${item.href}`);
                                        alert('Could not find this chapter in the book');
                                    }
                                } else if (isFileProtocol && this.spineItems) {
                                    // Regular EPUB with direct display (file:// protocol)
                                    const baseHref = item.href.split('#')[0];
                                    const chapterIndex = this.spineItems.findIndex(spineItem => {
                                        const spineBase = spineItem.href.split('#')[0];
                                        return baseHref.includes(spineBase) || spineBase.includes(baseHref);
                                    });
                                    
                                    if (chapterIndex !== -1) {
                                        await this.displayChapterDirect(chapterIndex);
                                        console.log(`Navigated to: ${itemLabel}`);
                                    } else {
                                        alert('Could not find this chapter in the book');
                                    }
                                } else {
                                    // Regular EPUB with rendition (http:// protocol)
                                    if (this.rendition) {
                                        await this.rendition.display(item.href);
                                        console.log(`Navigated to: ${itemLabel}`);
                                    }
                                }
                            } catch (error) {
                                console.error('Navigation error:', error);
                                alert('Failed to navigate to chapter: ' + error.message);
                            }
                        });

                        chaptersList.appendChild(itemDiv);

                        // Recursively render sub-items if they exist
                        if (item.subitems && item.subitems.length > 0) {
                            renderTocItems(item.subitems, level + 1);
                        }
                    }
                };

                renderTocItems(toc);
                chaptersContainer.appendChild(chaptersList);

                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Close';
                closeBtn.style.cssText = `
                    background: #2563eb;
                    color: white;
                    border: none;
                    padding: 0.75rem 1.5rem;
                    border-radius: 0.5rem;
                    cursor: pointer;
                    font-size: 1rem;
                    font-weight: 600;
                    margin-top: 1.5rem;
                    width: 100%;
                    transition: all 0.2s;
                `;

                closeBtn.addEventListener('click', () => modal.remove());
                chaptersContainer.appendChild(closeBtn);
                modal.appendChild(chaptersContainer);
                document.body.appendChild(modal);

                // Scroll to current chapter after a brief delay to ensure rendering is complete
                if (currentChapterElement) {
                    setTimeout(() => {
                        currentChapterElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }, 100);
                }

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
            }

            handleKeyboard(e) {
                if (!this.book) return;

                switch(e.key) {
                    case 'ArrowLeft':
                        if (this.pageMode === 'paginated' && !this.hasMediaOverlay) {
                            this.previousPage();
                        } else if (e.ctrlKey) {
                            this.previousSegment();
                        }
                        break;
                    case 'ArrowRight':
                        if (this.pageMode === 'paginated' && !this.hasMediaOverlay) {
                            this.nextPage();
                        } else if (e.ctrlKey) {
                            this.nextSegment();
                        }
                        break;
                    case ' ':
                        e.preventDefault();
                        if (this.hasMediaOverlay) {
                            this.togglePlay();
                        } else if (this.pageMode === 'paginated') {
                            this.nextPage();
                        }
                        break;
                    case 'f':
                    case 'F':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            this.toggleFullscreen();
                        }
                        break;
                    case 'Escape':
                        if (this.isFullscreen) {
                            this.toggleFullscreen();
                        }
                        break;
                }
            }

            showNotification(message, type = 'success') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 4000);
            }
        }

        const app = new EPUBMediaOverlayApp();
        console.log('=== Ready to load EPUBs ===');

        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then((registration) => {
                        console.log('‚úì Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates periodically
                        setInterval(() => {
                            registration.update();
                        }, 60 * 60 * 1000); // Check every hour
                        
                        // Listen for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New service worker available
                                    if (confirm('A new version is available! Reload to update?')) {
                                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                    });
                
                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data.type === 'BACKGROUND_SYNC') {
                        console.log('Background sync triggered');
                        // Trigger sync if auto-sync is enabled
                        if (app.syncManager.autoSyncEnabled) {
                            const books = app.libraryManager.getAllBooks();
                            app.syncManager.syncToGoogleDrive(books)
                                .then((result) => {
                                    if (result.success) {
                                        console.log('Background sync completed');
                                    }
                                });
                        }
                    }
                });
            });
        }

        // Handle install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('Install prompt available');
            e.preventDefault();
            deferredPrompt = e;
            
            // Show custom install notification
            const installNotification = document.createElement('div');
            installNotification.style.cssText = `
                position: fixed;
                bottom: 2rem;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 0.75rem;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                display: flex;
                align-items: center;
                gap: 1rem;
                max-width: 90vw;
                animation: slideUp 0.3s ease;
            `;
            
            installNotification.innerHTML = `
                <span style="font-weight: 600;">üì± Install EPUB Reader</span>
                <button id="installBtn" style="background: white; color: #2563eb; border: none; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; cursor: pointer;">
                    Install
                </button>
                <button id="dismissBtn" style="background: transparent; color: white; border: 1px solid rgba(255,255,255,0.3); padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer;">
                    Later
                </button>
            `;
            
            document.body.appendChild(installNotification);
            
            document.getElementById('installBtn').addEventListener('click', async () => {
                installNotification.remove();
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to install prompt: ${outcome}`);
                deferredPrompt = null;
            });
            
            document.getElementById('dismissBtn').addEventListener('click', () => {
                installNotification.remove();
            });
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                if (installNotification.parentNode) {
                    installNotification.remove();
                }
            }, 10000);
        });

        // Log when app is installed
        window.addEventListener('appinstalled', () => {
            console.log('‚úì EPUB Reader has been installed!');
            if (app.showNotification) {
                app.showNotification('App installed successfully! üéâ', 'success');
            }
        });

        // Add animation for install notification
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideUp {
                from {
                    transform: translateX(-50%) translateY(100px);
                    opacity: 0;
                }
                to {
                    transform: translateX(-50%) translateY(0);
                    opacity: 1;
                }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>

</html>
